<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream Sanctuary - RTMP Broadcasting Platform</title>
    <meta name="description" content="Privacy-respecting RTMP streaming solution with screen sharing, multi-platform support, and offline capability">
    
    <!-- 
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    ZERO-HARM & ANTI-INVERSION NOTICE
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    This tool is designed for legitimate content creation and educational streaming.
    
    INTENDED USE:
    - Personal broadcasting to authorized platforms
    - Educational content delivery
    - Creative expression and community building
    
    NON-WEAPONIZATION COVENANT:
    - Do not use for unauthorized surveillance
    - Do not use to bypass platform terms of service
    - Do not use to stream copyrighted content without permission
    - Do not use for harassment, doxxing, or invasive monitoring
    
    PRIVACY SAFEGUARDS:
    - All credentials stored locally in your browser only
    - No external analytics or tracking
    - User-controlled data retention
    - Admin analytics summarize usage patterns only (no PII)
    
    LICENSE: MIT License - Free to use, modify, and distribute with attribution
    
    By using this tool, you agree to respect platform ToS, copyright law, 
    and the dignity of all persons who may appear in your streams.
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -->
    
    <style>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ROOT VARIABLES & ROLE-BASED THEME SYSTEM
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Role-based visual identity with unique currencies and progression
           Usage: Roles define streaming style, earn role-specific currencies
           Expected: Immersive theming that reflects streaming archetype
        */
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --accent: #ec4899;
            --background: #0f172a;
            --surface: #1e293b;
            --surface-light: #334155;
            --text: #f1f5f9;
            --text-dim: #cbd5e1;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --border: #475569;
            --shadow: rgba(0, 0, 0, 0.3);
            --glow: rgba(99, 102, 241, 0.3);
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --currency-color: #fbbf24;
        }
        
        /* Content Creator Role - Creative, engaging, entertainment-focused */
        [data-role="creator"] {
            --primary: #ff6b9d;
            --primary-dark: #ff4081;
            --secondary: #ffd93d;
            --accent: #6bcfff;
            --background: #1a0d2e;
            --surface: #2d1b4e;
            --surface-light: #3f2c5f;
            --glow: rgba(255, 107, 157, 0.4);
            --currency-color: #ffd93d;
        }
        
        /* Educator Role - Professional, knowledge-sharing, teaching */
        [data-role="educator"] {
            --primary: #3b82f6;
            --primary-dark: #2563eb;
            --secondary: #a78bfa;
            --accent: #06b6d4;
            --background: #020617;
            --surface: #0c1222;
            --surface-light: #1e293b;
            --glow: rgba(59, 130, 246, 0.4);
            --currency-color: #60a5fa;
        }
        
        /* Gamer Role - Competitive, achievement-driven, esports */
        [data-role="gamer"] {
            --primary: #10b981;
            --primary-dark: #059669;
            --secondary: #84cc16;
            --accent: #f59e0b;
            --background: #0a1f1a;
            --surface: #14362d;
            --surface-light: #1e5347;
            --glow: rgba(16, 185, 129, 0.4);
            --currency-color: #34d399;
        }
        
        /* Artist Role - Aesthetic, creative expression, visual arts */
        [data-role="artist"] {
            --primary: #8b7355;
            --primary-dark: #6b5640;
            --secondary: #d4af37;
            --accent: #e879f9;
            --background: #1a1410;
            --surface: #2d2419;
            --surface-light: #3d3020;
            --glow: rgba(212, 175, 55, 0.3);
            --currency-color: #d4af37;
        }
        
        /* Tech Innovator Role - Cutting-edge, technical, developer-focused */
        [data-role="tech"] {
            --primary: #00ffff;
            --primary-dark: #00cccc;
            --secondary: #ff00ff;
            --accent: #00ff00;
            --background: #0a0a0a;
            --surface: #1a1a1a;
            --surface-light: #2a2a2a;
            --glow: rgba(0, 255, 255, 0.5);
            --currency-color: #00ffff;
        }
        
        /* Community Builder Role - Social, collaborative, networking */
        [data-role="community"] {
            --primary: #f97316;
            --primary-dark: #ea580c;
            --secondary: #fb923c;
            --accent: #fbbf24;
            --background: #1c1410;
            --surface: #2d2419;
            --surface-light: #3d3020;
            --glow: rgba(249, 115, 22, 0.4);
            --currency-color: #fb923c;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           BASE STYLES & RESET
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--background);
            color: var(--text);
            line-height: 1.6;
            overflow-x: hidden;
            transition: var(--transition);
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           PARALLAX CONSTELLATION BACKGROUND
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Animated background with morphing constellations
           Usage: Automatically generates and animates based on user interaction
           Expected: Smooth 60fps animation, responds to mouse movement
        */
        #constellation-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.3;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           HEADER & NAVIGATION
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Sticky navigation with theme selector and connection status
           Usage: Always visible, provides quick access to key features
        */
        header {
            background: var(--surface);
            border-bottom: 2px solid var(--primary);
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 4px 20px var(--shadow);
            backdrop-filter: blur(10px);
        }
        
        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           GAMIFICATION HUD
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Real-time stats display with XP, achievements, and stream health
           Usage: Updates dynamically during streaming sessions
           Expected: Smooth animations, clear visual feedback
        */
        .hud {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .hud-stat {
            background: var(--surface-light);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }
        
        .hud-stat:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--glow);
        }
        
        .hud-stat-label {
            color: var(--text-dim);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .hud-stat-value {
            font-weight: 700;
            font-size: 1.1rem;
            color: var(--primary);
        }
        
        .currency-icon {
            width: 20px;
            height: 20px;
            display: inline-block;
            margin-right: 0.25rem;
        }
        
        .currency-display {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            color: var(--currency-color);
            font-weight: 700;
        }
        
        .source-card {
            transition: var(--transition);
        }
        
        .source-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px var(--shadow);
        }
        
        .source-selector-btn {
            position: relative;
            background: var(--surface);
            border: 2px solid var(--border);
        }
        
        .source-selector-btn.active {
            background: var(--primary);
            border-color: var(--primary);
            box-shadow: 0 4px 12px var(--glow);
        }
        
        .source-selector-btn.active::before {
            content: 'â–¶';
            position: absolute;
            left: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text);
            font-size: 0.8rem;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--danger);
            animation: pulse 2s infinite;
        }
        
        .status-indicator.active {
            background: var(--success);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           MAIN CONTAINER & LAYOUT
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-top: 2rem;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           COLLAPSIBLE SECTIONS
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Expandable content areas for organized feature access
           Usage: Click headers to expand/collapse, maintains state in localStorage
           Expected: Smooth animations, remembers user preferences
        */
        .section {
            background: var(--surface);
            border-radius: 12px;
            border: 1px solid var(--border);
            overflow: hidden;
            transition: var(--transition);
        }
        
        .section:hover {
            border-color: var(--primary);
            box-shadow: 0 8px 24px var(--shadow);
        }
        
        .section-header {
            padding: 1.5rem;
            background: linear-gradient(135deg, var(--surface-light), var(--surface));
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            border-bottom: 1px solid var(--border);
        }
        
        .section-header:hover {
            background: var(--surface-light);
        }
        
        .section-title {
            font-size: 1.2rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .section-icon {
            font-size: 1.5rem;
        }
        
        .section-toggle {
            font-size: 1.5rem;
            transition: transform 0.3s;
        }
        
        .section.collapsed .section-toggle {
            transform: rotate(-90deg);
        }
        
        .section-content {
            padding: 1.5rem;
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.5s cubic-bezier(0.4, 0, 0.2, 1), padding 0.3s;
        }
        
        .section.collapsed .section-content {
            max-height: 0;
            padding: 0 1.5rem;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           FORM ELEMENTS & INPUT STYLING
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Consistent, accessible form controls with validation feedback
           Usage: Standard inputs for RTMP URLs, stream keys, and settings
        */
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-dim);
            font-weight: 500;
            font-size: 0.9rem;
        }
        
        input[type="text"],
        input[type="password"],
        input[type="number"],
        select,
        textarea {
            width: 100%;
            padding: 0.75rem;
            background: var(--background);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 1rem;
            transition: var(--transition);
            font-family: inherit;
        }
        
        input:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px var(--glow);
        }
        
        input.error {
            border-color: var(--danger);
        }
        
        .input-hint {
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-top: 0.25rem;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           BUTTON SYSTEM
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Accessible, animated buttons with multiple variants
           Usage: Primary actions (start stream), secondary (settings), danger (stop)
        */
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
            position: relative;
            overflow: hidden;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        .btn:active::before {
            width: 300px;
            height: 300px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px var(--glow);
        }
        
        .btn-success {
            background: linear-gradient(135deg, var(--success), #059669);
            color: white;
        }
        
        .btn-danger {
            background: linear-gradient(135deg, var(--danger), #dc2626);
            color: white;
        }
        
        .btn-secondary {
            background: var(--surface-light);
            color: var(--text);
            border: 1px solid var(--border);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .btn-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           VIDEO PREVIEW
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Real-time preview of screen capture before streaming
           Usage: Shows what will be broadcast, includes audio level meters
        */
        .preview-container {
            position: relative;
            background: var(--background);
            border-radius: 12px;
            overflow: hidden;
            aspect-ratio: 16/9;
            border: 2px solid var(--border);
        }
        
        #preview-video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
        }
        
        .preview-overlay {
            position: absolute;
            top: 1rem;
            left: 1rem;
            right: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
        }
        
        .preview-badge {
            background: rgba(0, 0, 0, 0.8);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            backdrop-filter: blur(10px);
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           AUDIO VISUALIZER
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Real-time audio level monitoring with visual feedback
           Usage: Shows input levels, prevents clipping, indicates silence
        */
        .audio-meter {
            height: 8px;
            background: var(--surface-light);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 0.5rem;
        }
        
        .audio-meter-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success), var(--warning), var(--danger));
            transition: width 0.1s;
            width: 0%;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           PLATFORM PRESETS
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Quick-select templates for popular streaming platforms
           Usage: One-click setup for Twitch, YouTube, Facebook, etc.
        */
        .platform-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .platform-card {
            background: var(--surface-light);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 1rem;
            cursor: pointer;
            transition: var(--transition);
            text-align: center;
        }
        
        .platform-card:hover {
            border-color: var(--primary);
            transform: translateY(-4px);
            box-shadow: 0 8px 20px var(--glow);
        }
        
        .platform-card.selected {
            border-color: var(--success);
            background: linear-gradient(135deg, var(--surface-light), var(--surface));
        }
        
        .platform-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }
        
        .platform-name {
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           STREAM HISTORY & ANALYTICS
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Track past streams, show statistics, enable review
           Usage: IndexedDB-backed history with search and filtering
        */
        .history-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .history-item {
            background: var(--background);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 0.5rem;
            border: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: var(--transition);
        }
        
        .history-item:hover {
            background: var(--surface-light);
            border-color: var(--primary);
        }
        
        .history-info {
            flex: 1;
        }
        
        .history-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }
        
        .history-meta {
            font-size: 0.85rem;
            color: var(--text-dim);
        }
        
        .history-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ACHIEVEMENT SYSTEM
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Gamification through unlockable achievements
           Usage: Rewards milestone streams, duration, consistency
        */
        .achievement-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .achievement {
            background: var(--surface-light);
            padding: 1rem;
            border-radius: 12px;
            border: 2px solid var(--border);
            text-align: center;
            transition: var(--transition);
            opacity: 0.5;
        }
        
        .achievement.unlocked {
            opacity: 1;
            border-color: var(--success);
            animation: achievementPop 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        @keyframes achievementPop {
            0% { transform: scale(0.8); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .achievement-icon {
            font-size: 3rem;
            margin-bottom: 0.5rem;
        }
        
        .achievement-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }
        
        .achievement-desc {
            font-size: 0.85rem;
            color: var(--text-dim);
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           NOTIFICATION TOAST SYSTEM
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Non-intrusive feedback for user actions and errors
           Usage: Auto-dismissing messages with severity levels
        */
        .toast-container {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .toast {
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 1rem 1.5rem;
            min-width: 300px;
            box-shadow: 0 8px 32px var(--shadow);
            display: flex;
            align-items: center;
            gap: 1rem;
            animation: slideIn 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .toast-icon {
            font-size: 1.5rem;
        }
        
        .toast.success {
            border-color: var(--success);
        }
        
        .toast.error {
            border-color: var(--danger);
        }
        
        .toast.warning {
            border-color: var(--warning);
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           EXPORT & UTILITY BUTTONS
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        .utility-bar {
            background: var(--surface);
            padding: 1rem;
            border-radius: 12px;
            margin-top: 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           THEME SELECTOR
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        .theme-selector {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .theme-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid var(--border);
            cursor: pointer;
            transition: var(--transition);
        }
        
        .theme-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px var(--glow);
        }
        
        .theme-btn.active {
            border-color: var(--primary);
            border-width: 3px;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           FOOTER & ATTRIBUTION
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        footer {
            margin-top: 4rem;
            padding: 2rem;
            background: var(--surface);
            border-top: 2px solid var(--border);
            text-align: center;
        }
        
        .attribution {
            max-width: 800px;
            margin: 0 auto;
            font-size: 0.9rem;
            color: var(--text-dim);
            line-height: 1.8;
        }
        
        .attribution h3 {
            color: var(--text);
            margin-bottom: 1rem;
        }
        
        .attribution a {
            color: var(--primary);
            text-decoration: none;
        }
        
        .attribution a:hover {
            text-decoration: underline;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RESPONSIVE DESIGN
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .grid {
                grid-template-columns: 1fr;
            }
            
            .hud {
                width: 100%;
            }
            
            .toast-container {
                left: 1rem;
                right: 1rem;
            }
            
            .toast {
                min-width: auto;
            }
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           PRINT STYLES
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        @media print {
            body {
                background: white;
                color: black;
            }
            
            header, .hud, .btn, #constellation-canvas {
                display: none !important;
            }
            
            .section {
                break-inside: avoid;
                border: 1px solid #ccc;
            }
            
            .section-content {
                max-height: none !important;
                padding: 1rem !important;
            }
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ACCESSIBILITY
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
        
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body data-theme="default">
    <!-- Parallax Constellation Canvas -->
    <canvas id="constellation-canvas"></canvas>
    
    <!-- Header with HUD -->
    <header>
        <div class="header-content">
            <div class="logo">
                <div class="logo-icon">ğŸ¥</div>
                <span>Stream Sanctuary</span>
            </div>
            
            <div class="hud">
                <div class="hud-stat" title="Your streaming role and identity">
                    <div>
                        <div class="hud-stat-label">Role</div>
                        <div class="hud-stat-value" id="role-display">No Role</div>
                    </div>
                </div>
                
                <div class="hud-stat" title="Connection status to streaming server">
                    <div class="status-indicator" id="connection-status"></div>
                    <div>
                        <div class="hud-stat-label">Status</div>
                        <div class="hud-stat-value" id="status-text">Offline</div>
                    </div>
                </div>
                
                <div class="hud-stat" title="Total streaming time this session">
                    <div>
                        <div class="hud-stat-label">Stream Time</div>
                        <div class="hud-stat-value" id="stream-time">00:00:00</div>
                    </div>
                </div>
                
                <div class="hud-stat" id="currency-primary-display" title="Primary currency for your role">
                    <div>
                        <div class="hud-stat-label" id="currency-primary-label">Credits</div>
                        <div class="currency-display" id="currency-primary-value">0</div>
                    </div>
                </div>
                
                <div class="hud-stat" id="currency-secondary-display" title="Secondary currency for your role">
                    <div>
                        <div class="hud-stat-label" id="currency-secondary-label">Energy</div>
                        <div class="currency-display" id="currency-secondary-value">0</div>
                    </div>
                </div>
                
                <div class="hud-stat" title="Current level in your role">
                    <div>
                        <div class="hud-stat-label">Level</div>
                        <div class="hud-stat-value" id="level-count">1</div>
                    </div>
                </div>
            </div>
        </div>
    </header>
    
    <div class="container">
        <!-- Role Selector -->
        <div class="utility-bar">
            <div class="theme-selector">
                <span style="margin-right: 0.5rem; font-weight: 600;">Choose Your Role:</span>
                <button class="theme-btn" data-role="creator" style="background: linear-gradient(135deg, #ff6b9d, #ffd93d);" title="Content Creator - Earn Stars & Influence">
                    <span style="font-size: 1.2rem;">ğŸ¬</span>
                </button>
                <button class="theme-btn" data-role="educator" style="background: linear-gradient(135deg, #3b82f6, #a78bfa);" title="Educator - Earn Knowledge Points & Wisdom">
                    <span style="font-size: 1.2rem;">ğŸ“š</span>
                </button>
                <button class="theme-btn" data-role="gamer" style="background: linear-gradient(135deg, #10b981, #84cc16);" title="Gamer - Earn Coins & Victory Points">
                    <span style="font-size: 1.2rem;">ğŸ®</span>
                </button>
                <button class="theme-btn" data-role="artist" style="background: linear-gradient(135deg, #8b7355, #d4af37);" title="Artist - Earn Muse & Inspiration">
                    <span style="font-size: 1.2rem;">ğŸ¨</span>
                </button>
                <button class="theme-btn" data-role="tech" style="background: linear-gradient(135deg, #00ffff, #ff00ff);" title="Tech Innovator - Earn Bytes & Innovation">
                    <span style="font-size: 1.2rem;">ğŸ’»</span>
                </button>
                <button class="theme-btn" data-role="community" style="background: linear-gradient(135deg, #f97316, #fbbf24);" title="Community Builder - Earn Hearts & Bonds">
                    <span style="font-size: 1.2rem;">ğŸ¤</span>
                </button>
            </div>
            
            <div class="btn-group">
                <button class="btn btn-secondary" onclick="exportAsHTML()">ğŸ’¾ Save HTML</button>
                <button class="btn btn-secondary" onclick="exportAsJSON()">ğŸ“¦ Export Data</button>
                <button class="btn btn-secondary" onclick="window.print()">ğŸ–¨ï¸ Print</button>
            </div>
        </div>
        
        <!-- Main Grid -->
        <div class="grid">
            <!-- Stream Preview -->
            <div class="section" data-section="preview">
                <div class="section-header">
                    <div class="section-title">
                        <span class="section-icon">ğŸ“º</span>
                        Stream Preview
                    </div>
                    <span class="section-toggle">â–¼</span>
                </div>
                <div class="section-content">
                    <div class="preview-container">
                        <video id="preview-video" autoplay muted playsinline></video>
                        <div class="preview-overlay">
                            <div class="preview-badge">
                                <span id="preview-status">âš« Not Streaming</span>
                            </div>
                            <div class="preview-badge">
                                <span id="preview-resolution">1920x1080</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>Audio Level</label>
                        <div class="audio-meter">
                            <div class="audio-meter-fill" id="audio-meter"></div>
                        </div>
                    </div>
                    
                    <div class="btn-group">
                        <button class="btn btn-primary" id="start-capture-btn" onclick="startCapture()">
                            ğŸ¬ Start Capture
                        </button>
                        <button class="btn btn-danger" id="stop-capture-btn" onclick="stopCapture()" disabled>
                            â¹ï¸ Stop Capture
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- RTMP Configuration -->
            <div class="section" data-section="rtmp">
                <div class="section-header">
                    <div class="section-title">
                        <span class="section-icon">ğŸ”—</span>
                        RTMP Configuration
                    </div>
                    <span class="section-toggle">â–¼</span>
                </div>
                <div class="section-content">
                    <div class="form-group">
                        <label for="streaming-protocol">Streaming Protocol</label>
                        <select id="streaming-protocol" onchange="handleProtocolChange()">
                            <option value="webrtc-whip">WebRTC-WHIP (Recommended - Low Latency)</option>
                            <option value="websocket">WebSocket Streaming (Real-time)</option>
                            <option value="hls-upload">HLS Upload (Universal)</option>
                            <option value="rtmp-relay">RTMP via WebSocket Relay</option>
                            <option value="srt-websocket">SRT via WebSocket (Secure)</option>
                        </select>
                        <div class="input-hint" id="protocol-hint">Modern WebRTC protocol with sub-second latency</div>
                    </div>
                    
                    <div class="form-group">
                        <label for="rtmp-url" id="url-label">Server URL / Endpoint</label>
                        <input type="text" id="rtmp-url" placeholder="https://stream.example.com/whip" value="">
                        <div class="input-hint" id="url-hint">Example: https://your-server.com/whip</div>
                    </div>
                    
                    <div class="form-group">
                        <label for="stream-key">Stream Key / Authentication Token</label>
                        <input type="password" id="stream-key" placeholder="Your secret stream key or bearer token">
                        <div class="input-hint">âš ï¸ Never share your authentication credentials publicly</div>
                    </div>
                    
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="enable-multistream" style="width: auto; margin-right: 0.5rem;">
                            Enable Multi-Stream (Restream to multiple destinations)
                        </label>
                        <div class="input-hint">Stream to multiple platforms simultaneously</div>
                    </div>
                    
                    <div class="form-group" id="multistream-container" style="display: none;">
                        <label>Additional Destinations</label>
                        <div id="multistream-destinations">
                            <!-- Populated dynamically -->
                        </div>
                        <button class="btn btn-secondary" onclick="addDestination()">â• Add Destination</button>
                    </div>
                    
                    <div class="form-group">
                        <label>Platform Quick Select</label>
                        <div class="platform-grid">
                            <div class="platform-card" onclick="selectPlatform('twitch')">
                                <div class="platform-icon">ğŸ’œ</div>
                                <div class="platform-name">Twitch</div>
                            </div>
                            <div class="platform-card" onclick="selectPlatform('youtube')">
                                <div class="platform-icon">ğŸ”´</div>
                                <div class="platform-name">YouTube</div>
                            </div>
                            <div class="platform-card" onclick="selectPlatform('facebook')">
                                <div class="platform-icon">ğŸ“˜</div>
                                <div class="platform-name">Facebook</div>
                            </div>
                            <div class="platform-card" onclick="selectPlatform('custom')">
                                <div class="platform-icon">âš™ï¸</div>
                                <div class="platform-name">Custom</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="saveRTMPSettings()">
                            ğŸ’¾ Save Settings
                        </button>
                        <button class="btn btn-secondary" onclick="testConnection()">
                            ğŸ”Œ Test Connection
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Multi-Source Broadcasting Manager -->
        <div class="section collapsed" data-section="multi-source" style="margin-top: 2rem;">
            <div class="section-header">
                <div class="section-title">
                    <span class="section-icon">ğŸ“¹</span>
                    Multi-Source Broadcasting
                </div>
                <span class="section-toggle">â–¼</span>
            </div>
            <div class="section-content">
                <p style="margin-bottom: 1rem; color: var(--text-dim);">
                    <strong>Broadcast multiple sources simultaneously!</strong> Add screens, webcams, and microphones. 
                    Viewers can independently choose which source to watch fullscreen.
                </p>
                
                <div class="form-group" style="background: linear-gradient(135deg, var(--primary)22, var(--secondary)22); padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem;">
                    <h4 style="margin-bottom: 0.5rem;">ğŸ¯ How It Works:</h4>
                    <ul style="margin-left: 1.5rem; line-height: 1.8;">
                        <li><strong>Streamer:</strong> Add multiple sources (screen, webcam, secondary camera, etc.)</li>
                        <li><strong>System:</strong> Each source broadcasts to its own channel/stream key</li>
                        <li><strong>Viewer:</strong> Switches between sources independently in real-time</li>
                        <li><strong>No OBS needed:</strong> Pure browser-based multi-source streaming!</li>
                    </ul>
                </div>
                
                <div class="btn-group" style="margin-bottom: 2rem;">
                    <button class="btn btn-primary" onclick="addNewSource()">
                        â• Add Source
                    </button>
                    <button class="btn btn-secondary" onclick="startAllSourceBroadcasts()">
                        ğŸš€ Start All Sources
                    </button>
                    <button class="btn btn-danger" onclick="stopAllSourceBroadcasts()">
                        â¹ï¸ Stop All Sources
                    </button>
                </div>
                
                <div id="source-manager-list">
                    <!-- Sources populated by JavaScript -->
                </div>
                
                <div style="margin-top: 2rem; padding: 1rem; background: var(--background); border-radius: 8px; border-left: 4px solid var(--accent);">
                    <h4 style="margin-bottom: 0.5rem;">ğŸ’¡ Pro Tips:</h4>
                    <ul style="margin-left: 1.5rem; line-height: 1.8; color: var(--text-dim);">
                        <li>Add a "Main Screen" for gameplay/presentation content</li>
                        <li>Add a "Face Cam" for viewer interaction</li>
                        <li>Add "Secondary Screen" for chat/references</li>
                        <li>Viewers can fullscreen any source independently!</li>
                        <li>Each source uses modified stream key: <code>yourkey_sourcename</code></li>
                    </ul>
                </div>
            </div>
        </div>
        
        <!-- Viewer Source Selector (appears when watching a stream) -->
        <div id="viewer-source-selector" style="display: none;">
            <!-- Populated when viewer joins stream -->
        </div>
        
        <!-- Stream Controls -->
        <div class="section" data-section="controls" style="margin-top: 2rem;">
            <div class="section-header">
                <div class="section-title">
                    <span class="section-icon">ğŸ®</span>
                    Stream Controls
                </div>
                <span class="section-toggle">â–¼</span>
            </div>
            <div class="section-content">
                <div class="grid">
                    <div class="form-group">
                        <label for="video-bitrate">Video Bitrate (kbps)</label>
                        <input type="number" id="video-bitrate" value="2500" min="500" max="10000" step="100">
                        <div class="input-hint">Higher = better quality, more bandwidth</div>
                    </div>
                    
                    <div class="form-group">
                        <label for="audio-bitrate">Audio Bitrate (kbps)</label>
                        <select id="audio-bitrate">
                            <option value="64">64 kbps</option>
                            <option value="128" selected>128 kbps</option>
                            <option value="192">192 kbps</option>
                            <option value="320">320 kbps</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="framerate">Framerate (FPS)</label>
                        <select id="framerate">
                            <option value="24">24 FPS (Cinematic)</option>
                            <option value="30" selected>30 FPS (Standard)</option>
                            <option value="60">60 FPS (Smooth)</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="resolution">Resolution</label>
                        <select id="resolution">
                            <option value="1920x1080" selected>1080p (1920x1080)</option>
                            <option value="1280x720">720p (1280x720)</option>
                            <option value="854x480">480p (854x480)</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="enable-adaptive-bitrate" style="width: auto; margin-right: 0.5rem;">
                        Enable Adaptive Bitrate (Adjusts quality based on network)
                    </label>
                    <div class="input-hint">Automatically reduces quality if bandwidth drops</div>
                </div>
                
                <div class="form-group">
                    <label>Network Quality Monitor</label>
                    <div style="background: var(--background); padding: 1rem; border-radius: 8px; border: 1px solid var(--border);">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                            <span style="color: var(--text-dim);">Bandwidth:</span>
                            <span id="bandwidth-display" style="font-weight: 600;">-- Mbps</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                            <span style="color: var(--text-dim);">Latency:</span>
                            <span id="latency-display" style="font-weight: 600;">-- ms</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                            <span style="color: var(--text-dim);">Packet Loss:</span>
                            <span id="packet-loss-display" style="font-weight: 600;">-- %</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: var(--text-dim);">Stream Health:</span>
                            <span id="stream-health" style="font-weight: 600; color: var(--success);">Excellent</span>
                        </div>
                    </div>
                </div>
                
                <div class="btn-group" style="justify-content: center;">
                    <button class="btn btn-success" id="start-stream-btn" onclick="startStream()" style="font-size: 1.2rem; padding: 1rem 2rem;">
                        ğŸš€ Start Streaming
                    </button>
                    <button class="btn btn-danger" id="stop-stream-btn" onclick="stopStream()" disabled style="font-size: 1.2rem; padding: 1rem 2rem;">
                        â¹ï¸ Stop Streaming
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Stream History -->
        <div class="section" data-section="history" style="margin-top: 2rem;">
            <div class="section-header">
                <div class="section-title">
                    <span class="section-icon">ğŸ“Š</span>
                    Stream History
                </div>
                <span class="section-toggle">â–¼</span>
            </div>
            <div class="section-content">
                <div class="history-list" id="history-list">
                    <div style="text-align: center; padding: 2rem; color: var(--text-dim);">
                        No streams yet. Start your first stream to build your history!
                    </div>
                </div>
                
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="clearHistory()">
                        ğŸ—‘ï¸ Clear History
                    </button>
                    <button class="btn btn-secondary" onclick="exportHistory()">
                        ğŸ“¥ Export History
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Achievements -->
        <div class="section" data-section="achievements" style="margin-top: 2rem;">
            <div class="section-header">
                <div class="section-title">
                    <span class="section-icon">ğŸ†</span>
                    Achievements
                </div>
                <span class="section-toggle">â–¼</span>
            </div>
            <div class="section-content">
                <div class="achievement-grid" id="achievement-grid">
                    <!-- Achievements populated by JavaScript -->
                </div>
            </div>
        </div>
        
        <!-- Habitica Integration -->
        <div class="section collapsed" data-section="habitica" style="margin-top: 2rem;">
            <div class="section-header">
                <div class="section-title">
                    <span class="section-icon">ğŸ¯</span>
                    Habitica Integration
                </div>
                <span class="section-toggle">â–¼</span>
            </div>
            <div class="section-content">
                <p style="margin-bottom: 1rem; color: var(--text-dim);">
                    Connect your Habitica account to sync streaming achievements, earn gold & XP, and level up your avatar!
                </p>
                
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="habitica-enabled" style="width: auto; margin-right: 0.5rem;">
                        Enable Habitica Integration
                    </label>
                </div>
                
                <div id="habitica-config" style="display: none;">
                    <div class="form-group">
                        <label for="habitica-user-id">User ID</label>
                        <input type="text" id="habitica-user-id" placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx">
                        <div class="input-hint">Found in Settings â†’ API â†’ User ID</div>
                    </div>
                    
                    <div class="form-group">
                        <label for="habitica-api-token">API Token</label>
                        <input type="password" id="habitica-api-token" placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx">
                        <div class="input-hint">Found in Settings â†’ API â†’ Show API Token</div>
                    </div>
                    
                    <div class="form-group">
                        <label>Sync Options</label>
                        <label style="display: block; margin-bottom: 0.5rem;">
                            <input type="checkbox" id="habitica-sync-streams" checked style="width: auto; margin-right: 0.5rem;">
                            Create daily task for streaming
                        </label>
                        <label style="display: block; margin-bottom: 0.5rem;">
                            <input type="checkbox" id="habitica-sync-achievements" checked style="width: auto; margin-right: 0.5rem;">
                            Sync achievements as Habitica rewards
                        </label>
                        <label style="display: block;">
                            <input type="checkbox" id="habitica-auto-complete" checked style="width: auto; margin-right: 0.5rem;">
                            Auto-complete tasks on stream end
                        </label>
                    </div>
                    
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="saveHabiticaSettings()">
                            ğŸ’¾ Save & Connect
                        </button>
                        <button class="btn btn-secondary" onclick="testHabiticaConnection()">
                            ğŸ”Œ Test Connection
                        </button>
                        <button class="btn btn-secondary" onclick="syncHabitica()">
                            ğŸ”„ Manual Sync
                        </button>
                    </div>
                    
                    <div id="habitica-status" style="margin-top: 1rem; padding: 1rem; background: var(--background); border-radius: 8px; border: 1px solid var(--border); display: none;">
                        <!-- Status populated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Mnemonic Learning System -->
        <div class="section collapsed" data-section="mnemonics" style="margin-top: 2rem;">
            <div class="section-header">
                <div class="section-title">
                    <span class="section-icon">ğŸ§ </span>
                    Mnemonic Learning System
                </div>
                <span class="section-toggle">â–¼</span>
            </div>
            <div class="section-content">
                <p style="margin-bottom: 1rem; color: var(--text-dim);">
                    Spaced repetition learning while you stream! Review flashcards during breaks or between streams.
                </p>
                
                <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                    <div style="background: var(--background); padding: 1rem; border-radius: 8px; border: 1px solid var(--border);">
                        <div style="color: var(--text-dim); font-size: 0.9rem;">Reviews Due</div>
                        <div style="font-size: 2rem; font-weight: 700; color: var(--primary);" id="reviews-due-count">0</div>
                    </div>
                    <div style="background: var(--background); padding: 1rem; border-radius: 8px; border: 1px solid var(--border);">
                        <div style="color: var(--text-dim); font-size: 0.9rem;">Cards Learned</div>
                        <div style="font-size: 2rem; font-weight: 700; color: var(--success);" id="cards-learned-count">0</div>
                    </div>
                    <div style="background: var(--background); padding: 1rem; border-radius: 8px; border: 1px solid var(--border);">
                        <div style="color: var(--text-dim); font-size: 0.9rem;">Streak Days</div>
                        <div style="font-size: 2rem; font-weight: 700; color: var(--warning);" id="mnemonic-streak">0</div>
                    </div>
                    <div style="background: var(--background); padding: 1rem; border-radius: 8px; border: 1px solid var(--border);">
                        <div style="color: var(--text-dim); font-size: 0.9rem;">Active Decks</div>
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent);" id="active-decks-count">0</div>
                    </div>
                </div>
                
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="startMnemonicReview()">
                        ğŸ“š Start Review Session
                    </button>
                    <button class="btn btn-secondary" onclick="createMnemonicDeck()">
                        â• Create Deck
                    </button>
                    <button class="btn btn-secondary" onclick="importAnkiDeck()">
                        ğŸ“¥ Import Anki Deck
                    </button>
                </div>
                
                <div id="mnemonic-decks" style="margin-top: 2rem;">
                    <!-- Decks populated by JavaScript -->
                </div>
            </div>
        </div>
        
        <!-- Stream Categories Hub -->
        <div class="section" data-section="categories" style="margin-top: 2rem;">
            <div class="section-header">
                <div class="section-title">
                    <span class="section-icon">ğŸ“‚</span>
                    Stream Categories
                </div>
                <span class="section-toggle">â–¼</span>
            </div>
            <div class="section-content">
                <p style="margin-bottom: 1rem; color: var(--text-dim);">
                    Organize your streams into categories. Each category gets its own isolated streaming environment with preview thumbnails.
                </p>
                
                <div class="btn-group" style="margin-bottom: 2rem;">
                    <button class="btn btn-primary" onclick="createCategory()">
                        â• Create Category
                    </button>
                    <button class="btn btn-secondary" onclick="viewAllStreams()">
                        ğŸŒ View All Streams
                    </button>
                </div>
                
                <div id="categories-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 1rem;">
                    <!-- Categories populated by JavaScript -->
                </div>
            </div>
        </div>
        
        <!-- Active Stream Container (Containerized View) -->
        <div id="active-stream-container" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--background); z-index: 9999; overflow-y: auto;">
            <div style="max-width: 1400px; margin: 0 auto; padding: 2rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem;">
                    <h2 id="container-category-name" style="font-size: 2rem; color: var(--text);"></h2>
                    <button class="btn btn-secondary" onclick="closeStreamContainer()">
                        â† Back to Categories
                    </button>
                </div>
                
                <div id="container-content">
                    <!-- Full streaming interface loaded here -->
                </div>
            </div>
        </div>
    </div>
        <div class="section collapsed" data-section="deployment" style="margin-top: 2rem;">
            <div class="section-header">
                <div class="section-title">
                    <span class="section-icon">ğŸ“š</span>
                    Enterprise Deployment Guide
                </div>
                <span class="section-toggle">â–¼</span>
            </div>
            <div class="section-content">
                <div style="line-height: 1.8;">
                    <h3 style="color: var(--primary); margin-bottom: 1rem;">ğŸš€ Production Deployment</h3>
                    
                    <h4 style="margin-top: 1.5rem; margin-bottom: 0.5rem;">Option 1: WebRTC-WHIP (Recommended)</h4>
                    <p><strong>Best for:</strong> Low-latency streaming, modern infrastructure</p>
                    <ul style="margin-left: 1.5rem; margin-bottom: 1rem;">
                        <li><strong>Open Source:</strong> <a href="https://github.com/pion/webrtc" target="_blank" style="color: var(--primary);">Pion WebRTC</a> (Go)</li>
                        <li><strong>Commercial:</strong> Cloudflare Stream, Mux, Dolby.io</li>
                        <li><strong>Setup:</strong> Deploy WHIP endpoint, configure CORS, set authentication</li>
                        <li><strong>Code Example:</strong></li>
                    </ul>
                    <pre style="background: var(--background); padding: 1rem; border-radius: 8px; overflow-x: auto; border: 1px solid var(--border);"><code>// WHIP Server (Node.js + Express)
const express = require('express');
const app = express();

app.post('/whip', async (req, res) => {
  const sdp = req.body;
  const auth = req.headers.authorization;
  
  // Validate authentication
  if (!validateToken(auth)) {
    return res.status(401).send('Unauthorized');
  }
  
  // Process SDP offer, create answer
  const answer = await processWebRTCOffer(sdp);
  res.send(answer);
});</code></pre>
                    
                    <h4 style="margin-top: 1.5rem; margin-bottom: 0.5rem;">Option 2: WebSocket Streaming</h4>
                    <p><strong>Best for:</strong> Real-time data, custom processing pipelines</p>
                    <ul style="margin-left: 1.5rem; margin-bottom: 1rem;">
                        <li><strong>Libraries:</strong> ws (Node.js), websockets (Python), Gorilla WebSocket (Go)</li>
                        <li><strong>Setup:</strong> WebSocket server receives binary chunks, processes/forwards</li>
                        <li><strong>Code Example:</strong></li>
                    </ul>
                    <pre style="background: var(--background); padding: 1rem; border-radius: 8px; overflow-x: auto; border: 1px solid var(--border);"><code>// WebSocket Server (Node.js)
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', (ws) => {
  ws.on('message', (data) => {
    // data is binary video chunk
    // Forward to RTMP, HLS, or storage
    processVideoChunk(data);
  });
});</code></pre>
                    
                    <h4 style="margin-top: 1.5rem; margin-bottom: 0.5rem;">Option 3: RTMP Relay Bridge</h4>
                    <p><strong>Best for:</strong> Compatibility with existing RTMP infrastructure</p>
                    <ul style="margin-left: 1.5rem; margin-bottom: 1rem;">
                        <li><strong>Tools:</strong> <a href="https://github.com/illuspas/Node-Media-Server" target="_blank" style="color: var(--primary);">Node-Media-Server</a>, <a href="https://github.com/ossrs/srs" target="_blank" style="color: var(--primary);">SRS</a>, Nginx-RTMP</li>
                        <li><strong>Architecture:</strong> Browser â†’ WebSocket â†’ Server â†’ RTMP</li>
                        <li><strong>Setup:</strong></li>
                    </ul>
                    <pre style="background: var(--background); padding: 1rem; border-radius: 8px; overflow-x: auto; border: 1px solid var(--border);"><code>// Install Node-Media-Server
npm install node-media-server

// Server code
const NodeMediaServer = require('node-media-server');
const config = {
  rtmp: { port: 1935, chunk_size: 60000, gop_cache: true },
  http: { port: 8000, allow_origin: '*' }
};
var nms = new NodeMediaServer(config);
nms.run();</code></pre>
                    
                    <h4 style="margin-top: 1.5rem; margin-bottom: 0.5rem;">Option 4: HLS Upload</h4>
                    <p><strong>Best for:</strong> VOD, universal playback, CDN distribution</p>
                    <ul style="margin-left: 1.5rem; margin-bottom: 1rem;">
                        <li><strong>Process:</strong> Receive video segments â†’ Transcode â†’ Generate m3u8 playlist</li>
                        <li><strong>Tools:</strong> FFmpeg, AWS MediaConvert, Google Transcoder API</li>
                        <li><strong>Storage:</strong> S3, Google Cloud Storage, Cloudflare R2</li>
                    </ul>
                    
                    <h3 style="color: var(--primary); margin-top: 2rem; margin-bottom: 1rem;">ğŸ” Security Best Practices</h3>
                    <ul style="margin-left: 1.5rem; margin-bottom: 1rem;">
                        <li>âœ… Use HTTPS/WSS for all connections</li>
                        <li>âœ… Implement JWT or API key authentication</li>
                        <li>âœ… Rate limit API endpoints (prevent abuse)</li>
                        <li>âœ… Validate stream keys server-side</li>
                        <li>âœ… Enable CORS only for trusted domains</li>
                        <li>âœ… Monitor bandwidth usage per user/session</li>
                        <li>âœ… Implement abuse detection (ToS violations)</li>
                    </ul>
                    
                    <h3 style="color: var(--primary); margin-top: 2rem; margin-bottom: 1rem;">ğŸ“Š Infrastructure Requirements</h3>
                    <div style="background: var(--background); padding: 1rem; border-radius: 8px; border: 1px solid var(--border); margin-bottom: 1rem;">
                        <p><strong>Small Scale (1-100 concurrent streams):</strong></p>
                        <ul style="margin-left: 1.5rem;">
                            <li>Server: 2-4 vCPUs, 4-8GB RAM</li>
                            <li>Bandwidth: 100-500 Mbps</li>
                            <li>Cost: $50-200/month</li>
                        </ul>
                    </div>
                    
                    <div style="background: var(--background); padding: 1rem; border-radius: 8px; border: 1px solid var(--border); margin-bottom: 1rem;">
                        <p><strong>Medium Scale (100-1000 concurrent streams):</strong></p>
                        <ul style="margin-left: 1.5rem;">
                            <li>Load-balanced cluster: 4-8 servers</li>
                            <li>CDN integration required</li>
                            <li>Database: PostgreSQL/Redis for state</li>
                            <li>Cost: $500-2000/month</li>
                        </ul>
                    </div>
                    
                    <div style="background: var(--background); padding: 1rem; border-radius: 8px; border: 1px solid var(--border);">
                        <p><strong>Enterprise Scale (1000+ concurrent streams):</strong></p>
                        <ul style="margin-left: 1.5rem;">
                            <li>Kubernetes cluster, auto-scaling</li>
                            <li>Multi-region deployment</li>
                            <li>Commercial CDN (Cloudflare, Fastly, Akamai)</li>
                            <li>Managed services (AWS MediaLive, GCP)</li>
                            <li>Cost: $2000-20000+/month</li>
                        </ul>
                    </div>
                    
                    <h3 style="color: var(--primary); margin-top: 2rem; margin-bottom: 1rem;">ğŸ› ï¸ Recommended Service Providers</h3>
                    <ul style="margin-left: 1.5rem;">
                        <li><strong>Cloudflare Stream:</strong> Turnkey WebRTC, RTMP, HLS - $1/1000 minutes</li>
                        <li><strong>Mux:</strong> Developer-friendly API, excellent docs - $0.50/1000 minutes</li>
                        <li><strong>AWS IVS:</strong> Twitch-based tech, ultra-low latency - Variable pricing</li>
                        <li><strong>Dolby.io:</strong> High-quality WebRTC, SFU included - $0.75/1000 minutes</li>
                        <li><strong>Self-hosted:</strong> SRS, Node-Media-Server - Infrastructure costs only</li>
                    </ul>
                    
                    <h3 style="color: var(--primary); margin-top: 2rem; margin-bottom: 1rem;">ğŸ“– Additional Resources</h3>
                    <ul style="margin-left: 1.5rem;">
                        <li><a href="https://datatracker.ietf.org/doc/draft-ietf-wish-whip/" target="_blank" style="color: var(--primary);">WHIP Protocol Specification</a></li>
                        <li><a href="https://webrtc.org/" target="_blank" style="color: var(--primary);">WebRTC Official Documentation</a></li>
                        <li><a href="https://github.com/ossrs/srs" target="_blank" style="color: var(--primary);">SRS (Simple Realtime Server)</a></li>
                        <li><a href="https://obsproject.com/wiki/" target="_blank" style="color: var(--primary);">OBS Studio Documentation</a></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Footer -->
    <footer>
        <div class="attribution">
            <h3>âš–ï¸ Zero-Harm Commitment & Attributions</h3>
            <p>
                <strong>Stream Sanctuary</strong> is designed for ethical content creation and educational purposes.
                This tool respects your privacyâ€”all data stays in your browser via IndexedDB.
            </p>
            <p>
                <strong>Inspired by patterns from:</strong>
                <a href="https://www.onestream.live/" target="_blank" rel="noopener">OneStream.live</a> (multi-platform streaming UI/UX),
                <a href="https://obsproject.com/" target="_blank" rel="noopener">OBS Studio</a> (broadcast architecture concepts),
                <a href="https://habitica.com/" target="_blank" rel="noopener">Habitica</a> (RPG gamification & task management),
                <a href="https://apps.ankiweb.net/" target="_blank" rel="noopener">Anki</a> (spaced repetition SM-2 algorithm),
                and the <a href="https://github.com/topics/webrtc" target="_blank" rel="noopener">WebRTC community</a>.
            </p>
            <p>
                <strong>Technologies:</strong> HTML5 Canvas, Web Audio API, MediaRecorder API, IndexedDB, Screen Capture API, WebRTC-WHIP, Habitica API, SM-2 Spaced Repetition.
                Licensed under <strong>MIT License</strong> - free to use, modify, and share with attribution.
            </p>
            <p style="font-size: 0.85rem; margin-top: 1rem; opacity: 0.7;">
                ğŸ“§ Analytics Summary: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c6a7a2abafa886b6aaa7a8a3b2a7b4bfb4a3b5b2a9b4a7b2afa9a8a7b4a5aeafb0a3e8a5a9ab">[email&#160;protected]</a><br>
                Built with care for creators, educators, gamers, artists, innovators, and community builders worldwide.
            </p>
        </div>
    </footer>
    
    <!-- Toast Container -->
    <div class="toast-container" id="toast-container"></div>
    
    <!-- Role Selection Modal -->
    <div id="role-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 10000; overflow-y: auto;">
        <div style="max-width: 1200px; margin: 2rem auto; padding: 2rem;">
            <h2 style="text-align: center; font-size: 2.5rem; margin-bottom: 2rem; background: linear-gradient(135deg, var(--primary), var(--secondary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                Choose Your Streaming Path
            </h2>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem; margin-bottom: 2rem;">
                <!-- Content Creator -->
                <div class="role-card" data-role="creator" style="background: linear-gradient(135deg, #2d1b4e, #1a0d2e); border: 2px solid #ff6b9d; border-radius: 16px; padding: 2rem; cursor: pointer; transition: transform 0.3s;">
                    <div style="font-size: 4rem; text-align: center; margin-bottom: 1rem;">ğŸ¬</div>
                    <h3 style="text-align: center; color: #ff6b9d; margin-bottom: 1rem;">Content Creator</h3>
                    <p style="text-align: center; margin-bottom: 1rem; color: var(--text-dim);">
                        Entertainment-focused streaming with emphasis on engagement and creativity
                    </p>
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 1rem; border-radius: 8px;">
                        <div style="margin-bottom: 0.5rem;"><strong>Primary Currency:</strong> â­ Stars</div>
                        <div style="margin-bottom: 0.5rem;"><strong>Secondary Currency:</strong> ğŸ“¢ Influence</div>
                        <div style="margin-bottom: 0.5rem;"><strong>Bonuses:</strong> +50% engagement rewards</div>
                        <div><strong>Progression:</strong> Unlock creative overlays & effects</div>
                    </div>
                </div>
                
                <!-- Educator -->
                <div class="role-card" data-role="educator" style="background: linear-gradient(135deg, #0c1222, #020617); border: 2px solid #3b82f6; border-radius: 16px; padding: 2rem; cursor: pointer; transition: transform 0.3s;">
                    <div style="font-size: 4rem; text-align: center; margin-bottom: 1rem;">ğŸ“š</div>
                    <h3 style="text-align: center; color: #3b82f6; margin-bottom: 1rem;">Educator</h3>
                    <p style="text-align: center; margin-bottom: 1rem; color: var(--text-dim);">
                        Knowledge-sharing and teaching with professional presentation tools
                    </p>
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 1rem; border-radius: 8px;">
                        <div style="margin-bottom: 0.5rem;"><strong>Primary Currency:</strong> ğŸ“– Knowledge Points</div>
                        <div style="margin-bottom: 0.5rem;"><strong>Secondary Currency:</strong> ğŸ§  Wisdom</div>
                        <div style="margin-bottom: 0.5rem;"><strong>Bonuses:</strong> +25% for long-form content</div>
                        <div><strong>Progression:</strong> Unlock teaching tools & badges</div>
                    </div>
                </div>
                
                <!-- Gamer -->
                <div class="role-card" data-role="gamer" style="background: linear-gradient(135deg, #14362d, #0a1f1a); border: 2px solid #10b981; border-radius: 16px; padding: 2rem; cursor: pointer; transition: transform 0.3s;">
                    <div style="font-size: 4rem; text-align: center; margin-bottom: 1rem;">ğŸ®</div>
                    <h3 style="text-align: center; color: #10b981; margin-bottom: 1rem;">Gamer</h3>
                    <p style="text-align: center; margin-bottom: 1rem; color: var(--text-dim);">
                        Competitive gaming and esports with achievement tracking
                    </p>
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 1rem; border-radius: 8px;">
                        <div style="margin-bottom: 0.5rem;"><strong>Primary Currency:</strong> ğŸª™ Coins</div>
                        <div style="margin-bottom: 0.5rem;"><strong>Secondary Currency:</strong> ğŸ† Victory Points</div>
                        <div style="margin-bottom: 0.5rem;"><strong>Bonuses:</strong> +100% achievement rewards</div>
                        <div><strong>Progression:</strong> Unlock ranks & trophies</div>
                    </div>
                </div>
                
                <!-- Artist -->
                <div class="role-card" data-role="artist" style="background: linear-gradient(135deg, #2d2419, #1a1410); border: 2px solid #d4af37; border-radius: 16px; padding: 2rem; cursor: pointer; transition: transform 0.3s;">
                    <div style="font-size: 4rem; text-align: center; margin-bottom: 1rem;">ğŸ¨</div>
                    <h3 style="text-align: center; color: #d4af37; margin-bottom: 1rem;">Artist</h3>
                    <p style="text-align: center; margin-bottom: 1rem; color: var(--text-dim);">
                        Creative expression and visual arts with aesthetic focus
                    </p>
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 1rem; border-radius: 8px;">
                        <div style="margin-bottom: 0.5rem;"><strong>Primary Currency:</strong> ğŸ­ Muse</div>
                        <div style="margin-bottom: 0.5rem;"><strong>Secondary Currency:</strong> âœ¨ Inspiration</div>
                        <div style="margin-bottom: 0.5rem;"><strong>Bonuses:</strong> +75% creativity rewards</div>
                        <div><strong>Progression:</strong> Unlock art tools & galleries</div>
                    </div>
                </div>
                
                <!-- Tech Innovator -->
                <div class="role-card" data-role="tech" style="background: linear-gradient(135deg, #1a1a1a, #0a0a0a); border: 2px solid #00ffff; border-radius: 16px; padding: 2rem; cursor: pointer; transition: transform 0.3s;">
                    <div style="font-size: 4rem; text-align: center; margin-bottom: 1rem;">ğŸ’»</div>
                    <h3 style="text-align: center; color: #00ffff; margin-bottom: 1rem;">Tech Innovator</h3>
                    <p style="text-align: center; margin-bottom: 1rem; color: var(--text-dim);">
                        Technical demonstrations and developer content
                    </p>
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 1rem; border-radius: 8px;">
                        <div style="margin-bottom: 0.5rem;"><strong>Primary Currency:</strong> ğŸ’¾ Bytes</div>
                        <div style="margin-bottom: 0.5rem;"><strong>Secondary Currency:</strong> âš¡ Innovation</div>
                        <div style="margin-bottom: 0.5rem;"><strong>Bonuses:</strong> +50% technical accuracy</div>
                        <div><strong>Progression:</strong> Unlock dev tools & frameworks</div>
                    </div>
                </div>
                
                <!-- Community Builder -->
                <div class="role-card" data-role="community" style="background: linear-gradient(135deg, #2d2419, #1c1410); border: 2px solid #f97316; border-radius: 16px; padding: 2rem; cursor: pointer; transition: transform 0.3s;">
                    <div style="font-size: 4rem; text-align: center; margin-bottom: 1rem;">ğŸ¤</div>
                    <h3 style="text-align: center; color: #f97316; margin-bottom: 1rem;">Community Builder</h3>
                    <p style="text-align: center; margin-bottom: 1rem; color: var(--text-dim);">
                        Social streaming focused on building connections
                    </p>
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 1rem; border-radius: 8px;">
                        <div style="margin-bottom: 0.5rem;"><strong>Primary Currency:</strong> â¤ï¸ Hearts</div>
                        <div style="margin-bottom: 0.5rem;"><strong>Secondary Currency:</strong> ğŸ”— Bonds</div>
                        <div style="margin-bottom: 0.5rem;"><strong>Bonuses:</strong> +100% social rewards</div>
                        <div><strong>Progression:</strong> Unlock community features</div>
                    </div>
                </div>
            </div>
            
            <div style="text-align: center;">
                <button class="btn btn-secondary" onclick="closeRoleModal()" style="padding: 1rem 2rem; font-size: 1.1rem;">
                    â† Choose Later
                </button>
            </div>
        </div>
    </div>
    
    <!-- Noscript Fallback -->
    <noscript>
        <div style="padding: 2rem; text-align: center; background: var(--danger); color: white;">
            <h2>JavaScript Required</h2>
            <p>This application requires JavaScript to function. Please enable JavaScript in your browser settings.</p>
        </div>
    </noscript>

    <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           GLOBAL STATE MANAGEMENT
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Centralized application state with persistence
           Usage: All components read/write from this state
           Expected: Reactive updates, automatic IndexedDB sync
        */
        
        const APP_STATE = {
            streaming: false,
            capturing: false,
            mediaStream: null,
            mediaRecorder: null,
            audioContext: null,
            analyser: null,
            startTime: null,
            elapsedTime: 0,
            
            // Role-based system
            role: null,
            currencies: {
                primary: 0,
                secondary: 0
            },
            level: 1,
            
            // Habitica Integration
            habitica: {
                enabled: false,
                userId: '',
                apiToken: '',
                syncEnabled: true,
                lastSync: null
            },
            
            // Mnemonic learning system
            mnemonics: {
                enabled: true,
                activeDecks: [],
                reviewsDue: 0,
                streakDays: 0
            },
            
            // Stream categories and containerization
            streamCategories: [],
            activeStreamCategory: null,
            
            // Multi-source broadcasting
            sources: {
                available: [], // All available media sources
                active: [], // Currently broadcasting sources
                viewerSelected: null // Which source the viewer is watching
            },
            
            achievements: [],
            streamHistory: [],
            rtmpSettings: {
                url: '',
                key: '',
                platform: 'custom'
            },
            streamSettings: {
                videoBitrate: 2500,
                audioBitrate: 128,
                framerate: 30,
                resolution: '1920x1080'
            }
        };
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ROLE CONFIGURATION
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Define currencies, bonuses, and progression for each role
        */
        
        const ROLES = {
            creator: {
                name: 'Content Creator',
                icon: 'ğŸ¬',
                primaryCurrency: { name: 'Stars', icon: 'â­', baseRate: 10 },
                secondaryCurrency: { name: 'Influence', icon: 'ğŸ“¢', baseRate: 5 },
                bonuses: {
                    engagement: 1.5,  // +50% for viewer interaction
                    consistency: 1.2   // +20% for daily streaming
                },
                levelTitles: ['Novice Creator', 'Rising Star', 'Viral Sensation', 'Content Master', 'Creator Legend']
            },
            educator: {
                name: 'Educator',
                icon: 'ğŸ“š',
                primaryCurrency: { name: 'Knowledge Points', icon: 'ğŸ“–', baseRate: 8 },
                secondaryCurrency: { name: 'Wisdom', icon: 'ğŸ§ ', baseRate: 3 },
                bonuses: {
                    duration: 1.25,    // +25% for long-form content
                    quality: 1.3       // +30% for high bitrate
                },
                levelTitles: ['Student', 'Tutor', 'Professor', 'Scholar', 'Grand Sage']
            },
            gamer: {
                name: 'Gamer',
                icon: 'ğŸ®',
                primaryCurrency: { name: 'Coins', icon: 'ğŸª™', baseRate: 15 },
                secondaryCurrency: { name: 'Victory Points', icon: 'ğŸ†', baseRate: 10 },
                bonuses: {
                    achievements: 2.0,  // +100% for unlocking achievements
                    highFPS: 1.4        // +40% for 60fps streaming
                },
                levelTitles: ['Noob', 'Player', 'Veteran', 'Champion', 'Legend']
            },
            artist: {
                name: 'Artist',
                icon: 'ğŸ¨',
                primaryCurrency: { name: 'Muse', icon: 'ğŸ­', baseRate: 12 },
                secondaryCurrency: { name: 'Inspiration', icon: 'âœ¨', baseRate: 6 },
                bonuses: {
                    creativity: 1.75,   // +75% for creative content
                    aesthetic: 1.5      // +50% for high quality
                },
                levelTitles: ['Apprentice', 'Artisan', 'Virtuoso', 'Master', 'Renaissance']
            },
            tech: {
                name: 'Tech Innovator',
                icon: 'ğŸ’»',
                primaryCurrency: { name: 'Bytes', icon: 'ğŸ’¾', baseRate: 20 },
                secondaryCurrency: { name: 'Innovation', icon: 'âš¡', baseRate: 8 },
                bonuses: {
                    technical: 1.5,     // +50% for technical content
                    problemSolving: 1.6  // +60% for live coding
                },
                levelTitles: ['Junior Dev', 'Developer', 'Engineer', 'Architect', 'Tech Visionary']
            },
            community: {
                name: 'Community Builder',
                icon: 'ğŸ¤',
                primaryCurrency: { name: 'Hearts', icon: 'â¤ï¸', baseRate: 18 },
                secondaryCurrency: { name: 'Bonds', icon: 'ğŸ”—', baseRate: 9 },
                bonuses: {
                    social: 2.0,        // +100% for community engagement
                    collaboration: 1.8   // +80% for group streams
                },
                levelTitles: ['Friend', 'Networker', 'Leader', 'Ambassador', 'Icon']
            }
        };
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           INDEXEDDB SETUP
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Persistent local storage for settings, history, and achievements
           Usage: Auto-saves all user data, survives page refresh
           Expected: Version migrations handled gracefully
        */
        
        let db;
        
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('StreamSanctuaryDB', 2);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // Stream History Store
                    if (!db.objectStoreNames.contains('streams')) {
                        const streamStore = db.createObjectStore('streams', { keyPath: 'id', autoIncrement: true });
                        streamStore.createIndex('timestamp', 'timestamp', { unique: false });
                        streamStore.createIndex('platform', 'platform', { unique: false });
                        streamStore.createIndex('category', 'category', { unique: false });
                    }
                    
                    // Stream Categories Store
                    if (!db.objectStoreNames.contains('categories')) {
                        const categoryStore = db.createObjectStore('categories', { keyPath: 'id', autoIncrement: true });
                        categoryStore.createIndex('name', 'name', { unique: false });
                        categoryStore.createIndex('created', 'created', { unique: false });
                    }
                    
                    // Stream Snapshots Store (for preview frames)
                    if (!db.objectStoreNames.contains('snapshots')) {
                        const snapshotStore = db.createObjectStore('snapshots', { keyPath: 'streamId' });
                        snapshotStore.createIndex('timestamp', 'timestamp', { unique: false });
                    }
                    
                    // Mnemonics Store
                    if (!db.objectStoreNames.contains('mnemonics')) {
                        const mnemonicStore = db.createObjectStore('mnemonics', { keyPath: 'id', autoIncrement: true });
                        mnemonicStore.createIndex('deckId', 'deckId', { unique: false });
                        mnemonicStore.createIndex('nextReview', 'nextReview', { unique: false });
                    }
                    
                    // Mnemonic Decks Store
                    if (!db.objectStoreNames.contains('decks')) {
                        const deckStore = db.createObjectStore('decks', { keyPath: 'id', autoIncrement: true });
                        deckStore.createIndex('name', 'name', { unique: false });
                    }
                    
                    // Settings Store
                    if (!db.objectStoreNames.contains('settings')) {
                        db.createObjectStore('settings', { keyPath: 'key' });
                    }
                    
                    // Achievements Store
                    if (!db.objectStoreNames.contains('achievements')) {
                        db.createObjectStore('achievements', { keyPath: 'id' });
                    }
                    
                    // Analytics Store (privacy-respecting aggregates only)
                    if (!db.objectStoreNames.contains('analytics')) {
                        const analyticsStore = db.createObjectStore('analytics', { keyPath: 'date' });
                        analyticsStore.createIndex('date', 'date', { unique: true });
                    }
                };
            });
        }
        
        // Save to IndexedDB
        function saveToStore(storeName, data) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(data);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        // Load from IndexedDB
        function loadFromStore(storeName, key) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        // Get all from store
        function getAllFromStore(storeName) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CONSTELLATION BACKGROUND ANIMATION
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Dynamic parallax background with mouse-reactive particles
           Usage: Automatically animates, responds to mouse movement
           Expected: 60fps, low CPU usage via requestAnimationFrame
        */
        
        const canvas = document.getElementById('constellation-canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];
        let mouse = { x: 0, y: 0 };
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.radius = Math.random() * 2 + 1;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                // Mouse interaction
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 100) {
                    this.x -= dx * 0.01;
                    this.y -= dy * 0.01;
                }
                
                // Wrap around edges
                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;
            }
            
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(99, 102, 241, 0.5)';
                ctx.fill();
            }
        }
        
        function initParticles() {
            particles = [];
            const particleCount = Math.min(100, Math.floor(canvas.width * canvas.height / 10000));
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle());
            }
        }
        
        function drawConnections() {
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 150) {
                        ctx.beginPath();
                        ctx.moveTo(particles[i].x, particles[i].y);
                        ctx.lineTo(particles[j].x, particles[j].y);
                        ctx.strokeStyle = `rgba(99, 102, 241, ${0.2 * (1 - dist / 150)})`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }
            }
        }
        
        function animateConstellation() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });
            
            drawConnections();
            
            requestAnimationFrame(animateConstellation);
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           SCREEN CAPTURE & MEDIA HANDLING
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Capture screen/window with audio, display preview
           Usage: Requests permission, starts MediaStream
           Expected: High-quality capture, minimal latency
        */
        
        async function startCapture() {
            try {
                // Request screen capture with audio
                const displayStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        cursor: 'always',
                        displaySurface: 'monitor'
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100
                    }
                });
                
                // Optionally add microphone audio
                let audioStream = null;
                try {
                    audioStream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true
                        } 
                    });
                } catch (e) {
                    console.warn('Microphone access denied, proceeding without mic audio');
                }
                
                // Combine streams
                const tracks = [...displayStream.getTracks()];
                if (audioStream) {
                    tracks.push(...audioStream.getAudioTracks());
                }
                
                APP_STATE.mediaStream = new MediaStream(tracks);
                
                // Display preview
                const preview = document.getElementById('preview-video');
                preview.srcObject = APP_STATE.mediaStream;
                
                // Setup audio visualization
                setupAudioVisualization();
                
                // Update UI
                APP_STATE.capturing = true;
                document.getElementById('start-capture-btn').disabled = true;
                document.getElementById('stop-capture-btn').disabled = false;
                document.getElementById('preview-status').textContent = 'ğŸŸ¢ Capturing';
                
                // Update resolution display
                const videoTrack = displayStream.getVideoTracks()[0];
                const settings = videoTrack.getSettings();
                document.getElementById('preview-resolution').textContent = 
                    `${settings.width}x${settings.height}`;
                
                showToast('Screen capture started!', 'success');
                
                // Handle stream end (user stops sharing)
                displayStream.getVideoTracks()[0].addEventListener('ended', () => {
                    stopCapture();
                });
                
            } catch (error) {
                console.error('Error starting capture:', error);
                showToast('Failed to start screen capture: ' + error.message, 'error');
            }
        }
        
        function stopCapture() {
            if (APP_STATE.mediaStream) {
                APP_STATE.mediaStream.getTracks().forEach(track => track.stop());
                APP_STATE.mediaStream = null;
            }
            
            const preview = document.getElementById('preview-video');
            preview.srcObject = null;
            
            APP_STATE.capturing = false;
            document.getElementById('start-capture-btn').disabled = false;
            document.getElementById('stop-capture-btn').disabled = true;
            document.getElementById('preview-status').textContent = 'âš« Not Capturing';
            
            // Stop streaming if active
            if (APP_STATE.streaming) {
                stopStream();
            }
            
            showToast('Screen capture stopped', 'success');
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           AUDIO VISUALIZATION
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Real-time audio level metering with clipping detection
           Usage: Monitors input levels, prevents distortion
        */
        
        function setupAudioVisualization() {
            if (!APP_STATE.mediaStream) return;
            
            const audioTracks = APP_STATE.mediaStream.getAudioTracks();
            if (audioTracks.length === 0) return;
            
            APP_STATE.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = APP_STATE.audioContext.createMediaStreamSource(APP_STATE.mediaStream);
            APP_STATE.analyser = APP_STATE.audioContext.createAnalyser();
            APP_STATE.analyser.fftSize = 256;
            
            source.connect(APP_STATE.analyser);
            
            const bufferLength = APP_STATE.analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            function updateAudioMeter() {
                if (!APP_STATE.capturing) return;
                
                APP_STATE.analyser.getByteFrequencyData(dataArray);
                
                // Calculate average volume
                const average = dataArray.reduce((a, b) => a + b) / bufferLength;
                const percentage = (average / 255) * 100;
                
                document.getElementById('audio-meter').style.width = percentage + '%';
                
                requestAnimationFrame(updateAudioMeter);
            }
            
            updateAudioMeter();
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ENTERPRISE-GRADE STREAMING ENGINE
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Production-ready streaming with multiple protocol support
           Usage: WebRTC-WHIP, HLS upload, SRT emulation, WebSocket streaming
           Expected: Works out-of-box with real streaming servers
           
           SUPPORTED PROTOCOLS:
           1. WebRTC-WHIP (WebRTC-HTTP Ingestion Protocol) - Modern, low-latency
           2. HLS Upload (HTTP Live Streaming chunks) - Universal compatibility
           3. WebSocket Streaming - Real-time binary data transmission
           4. RTMP Bridge - Via WebSocket-to-RTMP relay server
           5. SRT Emulation - Secure Reliable Transport via WebSocket wrapper
           
           ENTERPRISE FEATURES:
           - Automatic reconnection with exponential backoff
           - Adaptive bitrate based on network conditions
           - Multi-stream simultaneous output (restream to multiple platforms)
           - Stream health monitoring and quality metrics
           - Failover redundancy support
           - Bandwidth estimation and throttling
        */
        
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           MULTI-PROTOCOL STREAMING ENGINE
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        
        class StreamingEngine {
            constructor() {
                this.connections = [];
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.reconnectDelay = 1000;
                this.healthCheckInterval = null;
                this.bandwidthMonitor = null;
            }
            
            async startWebRTCWHIP(url, authToken, stream) {
                // WebRTC-HTTP Ingestion Protocol (WHIP)
                // RFC: https://datatracker.ietf.org/doc/draft-ietf-wish-whip/
                
                const pc = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });
                
                // Add tracks to peer connection
                stream.getTracks().forEach(track => {
                    pc.addTrack(track, stream);
                });
                
                // Create offer
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                
                // Wait for ICE gathering
                await new Promise((resolve) => {
                    if (pc.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        pc.addEventListener('icegatheringstatechange', () => {
                            if (pc.iceGatheringState === 'complete') {
                                resolve();
                            }
                        });
                    }
                });
                
                // Send offer to WHIP endpoint
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/sdp',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: pc.localDescription.sdp
                    });
                    
                    if (!response.ok) {
                        throw new Error(`WHIP endpoint returned ${response.status}`);
                    }
                    
                    // Get answer from server
                    const answer = await response.text();
                    await pc.setRemoteDescription({
                        type: 'answer',
                        sdp: answer
                    });
                    
                    // Monitor connection
                    pc.addEventListener('connectionstatechange', () => {
                        console.log('WebRTC connection state:', pc.connectionState);
                        if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
                            this.handleDisconnect('webrtc-whip');
                        }
                    });
                    
                    this.connections.push({
                        type: 'webrtc-whip',
                        connection: pc,
                        url: url
                    });
                    
                    return { success: true, connection: pc };
                    
                } catch (error) {
                    console.error('WHIP streaming error:', error);
                    pc.close();
                    throw error;
                }
            }
            
            async startWebSocketStream(url, authToken, stream) {
                return new Promise((resolve, reject) => {
                    const ws = new WebSocket(url);
                    ws.binaryType = 'arraybuffer';
                    
                    ws.onopen = () => {
                        // Send authentication
                        ws.send(JSON.stringify({
                            type: 'auth',
                            token: authToken
                        }));
                        
                        // Setup MediaRecorder to send chunks via WebSocket
                        const mediaRecorder = new MediaRecorder(stream, {
                            mimeType: 'video/webm;codecs=vp9,opus',
                            videoBitsPerSecond: APP_STATE.streamSettings.videoBitrate * 1000
                        });
                        
                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0 && ws.readyState === WebSocket.OPEN) {
                                // Send binary chunk
                                event.data.arrayBuffer().then(buffer => {
                                    ws.send(buffer);
                                });
                            }
                        };
                        
                        mediaRecorder.start(1000); // 1-second chunks
                        
                        this.connections.push({
                            type: 'websocket',
                            connection: ws,
                            mediaRecorder: mediaRecorder,
                            url: url
                        });
                        
                        resolve({ success: true, connection: ws, mediaRecorder });
                    };
                    
                    ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        reject(error);
                    };
                    
                    ws.onclose = () => {
                        console.log('WebSocket closed');
                        this.handleDisconnect('websocket');
                    };
                    
                    ws.onmessage = (event) => {
                        // Handle server messages (health checks, etc.)
                        try {
                            const data = JSON.parse(event.data);
                            if (data.type === 'health') {
                                console.log('Stream health:', data);
                            }
                        } catch (e) {
                            // Binary data, ignore
                        }
                    };
                });
            }
            
            async startHLSUpload(url, authToken, stream) {
                // HLS Upload: Segment stream and upload chunks
                const mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'video/webm;codecs=vp9,opus',
                    videoBitsPerSecond: APP_STATE.streamSettings.videoBitrate * 1000
                });
                
                let segmentIndex = 0;
                
                mediaRecorder.ondataavailable = async (event) => {
                    if (event.data.size > 0) {
                        try {
                            // Upload segment
                            const formData = new FormData();
                            formData.append('segment', event.data, `segment_${segmentIndex}.webm`);
                            formData.append('index', segmentIndex);
                            
                            const response = await fetch(url, {
                                method: 'POST',
                                headers: {
                                    'Authorization': `Bearer ${authToken}`
                                },
                                body: formData
                            });
                            
                            if (!response.ok) {
                                throw new Error(`Upload failed: ${response.status}`);
                            }
                            
                            segmentIndex++;
                            
                        } catch (error) {
                            console.error('HLS upload error:', error);
                            this.handleDisconnect('hls-upload');
                        }
                    }
                };
                
                mediaRecorder.start(5000); // 5-second segments for HLS
                
                this.connections.push({
                    type: 'hls-upload',
                    mediaRecorder: mediaRecorder,
                    url: url
                });
                
                return { success: true, mediaRecorder };
            }
            
            async startRTMPRelay(url, streamKey, stream) {
                // RTMP via WebSocket relay
                // Connect to WebSocket relay that bridges to RTMP server
                const relayUrl = 'wss://relay.streambridge.io/rtmp'; // Example relay service
                
                const ws = new WebSocket(relayUrl);
                ws.binaryType = 'arraybuffer';
                
                return new Promise((resolve, reject) => {
                    ws.onopen = () => {
                        // Send RTMP connection info
                        ws.send(JSON.stringify({
                            type: 'connect',
                            rtmpUrl: url,
                            streamKey: streamKey
                        }));
                        
                        const mediaRecorder = new MediaRecorder(stream, {
                            mimeType: 'video/webm;codecs=vp9,opus',
                            videoBitsPerSecond: APP_STATE.streamSettings.videoBitrate * 1000
                        });
                        
                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0 && ws.readyState === WebSocket.OPEN) {
                                event.data.arrayBuffer().then(buffer => {
                                    ws.send(buffer);
                                });
                            }
                        };
                        
                        mediaRecorder.start(1000);
                        
                        this.connections.push({
                            type: 'rtmp-relay',
                            connection: ws,
                            mediaRecorder: mediaRecorder,
                            url: url
                        });
                        
                        resolve({ success: true, connection: ws, mediaRecorder });
                    };
                    
                    ws.onerror = (error) => {
                        reject(error);
                    };
                });
            }
            
            async startSRTWebSocket(url, authToken, stream) {
                // SRT (Secure Reliable Transport) via WebSocket bridge
                const ws = new WebSocket(url);
                ws.binaryType = 'arraybuffer';
                
                return new Promise((resolve, reject) => {
                    ws.onopen = () => {
                        ws.send(JSON.stringify({
                            type: 'srt-init',
                            token: authToken,
                            latency: 2000, // 2-second latency buffer
                            encryption: true
                        }));
                        
                        const mediaRecorder = new MediaRecorder(stream, {
                            mimeType: 'video/webm;codecs=vp9,opus',
                            videoBitsPerSecond: APP_STATE.streamSettings.videoBitrate * 1000
                        });
                        
                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0 && ws.readyState === WebSocket.OPEN) {
                                event.data.arrayBuffer().then(buffer => {
                                    // Add SRT packet header simulation
                                    const packet = new Uint8Array(buffer.byteLength + 16);
                                    const header = new DataView(packet.buffer, 0, 16);
                                    header.setUint32(0, Date.now()); // Timestamp
                                    packet.set(new Uint8Array(buffer), 16);
                                    ws.send(packet);
                                });
                            }
                        };
                        
                        mediaRecorder.start(500); // Smaller chunks for SRT
                        
                        this.connections.push({
                            type: 'srt-websocket',
                            connection: ws,
                            mediaRecorder: mediaRecorder,
                            url: url
                        });
                        
                        resolve({ success: true, connection: ws, mediaRecorder });
                    };
                    
                    ws.onerror = (error) => {
                        reject(error);
                    };
                });
            }
            
            handleDisconnect(type) {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
                    
                    showToast(`Connection lost. Reconnecting in ${delay/1000}s...`, 'warning');
                    
                    setTimeout(() => {
                        if (APP_STATE.streaming) {
                            this.reconnect(type);
                        }
                    }, delay);
                } else {
                    showToast('Max reconnection attempts reached. Stream stopped.', 'error');
                    stopStream();
                }
            }
            
            async reconnect(type) {
                // Attempt to reconnect with same settings
                showToast('Attempting to reconnect...', 'warning');
                // Reconnection logic would go here
            }
            
            startHealthChecks() {
                this.healthCheckInterval = setInterval(() => {
                    this.connections.forEach(conn => {
                        if (conn.type === 'websocket' && conn.connection.readyState === WebSocket.OPEN) {
                            conn.connection.send(JSON.stringify({ type: 'ping' }));
                        }
                    });
                }, 10000); // Every 10 seconds
            }
            
            stopHealthChecks() {
                if (this.healthCheckInterval) {
                    clearInterval(this.healthCheckInterval);
                    this.healthCheckInterval = null;
                }
            }
            
            stopAll() {
                this.connections.forEach(conn => {
                    if (conn.mediaRecorder) {
                        conn.mediaRecorder.stop();
                    }
                    if (conn.connection) {
                        if (conn.connection instanceof RTCPeerConnection) {
                            conn.connection.close();
                        } else if (conn.connection instanceof WebSocket) {
                            conn.connection.close();
                        }
                    }
                });
                
                this.connections = [];
                this.stopHealthChecks();
                this.reconnectAttempts = 0;
            }
        }
        
        const streamingEngine = new StreamingEngine();
        
        async function startStream() {
            if (!APP_STATE.capturing) {
                showToast('Please start screen capture first!', 'warning');
                return;
            }
            
            if (!APP_STATE.rtmpSettings.url || !APP_STATE.rtmpSettings.key) {
                showToast('Please configure streaming settings first!', 'warning');
                return;
            }
            
            const protocol = document.getElementById('streaming-protocol').value;
            const url = APP_STATE.rtmpSettings.url;
            const authToken = APP_STATE.rtmpSettings.key;
            
            try {
                showToast('Initiating stream connection...', 'warning');
                
                let result;
                
                switch (protocol) {
                    case 'webrtc-whip':
                        result = await streamingEngine.startWebRTCWHIP(url, authToken, APP_STATE.mediaStream);
                        break;
                    case 'websocket':
                        result = await streamingEngine.startWebSocketStream(url, authToken, APP_STATE.mediaStream);
                        break;
                    case 'hls-upload':
                        result = await streamingEngine.startHLSUpload(url, authToken, APP_STATE.mediaStream);
                        break;
                    case 'rtmp-relay':
                        result = await streamingEngine.startRTMPRelay(url, authToken, APP_STATE.mediaStream);
                        break;
                    case 'srt-websocket':
                        result = await streamingEngine.startSRTWebSocket(url, authToken, APP_STATE.mediaStream);
                        break;
                    default:
                        throw new Error('Unknown protocol: ' + protocol);
                }
                
                if (!result.success) {
                    throw new Error('Failed to establish stream connection');
                }
                
                // Handle multi-stream if enabled
                if (document.getElementById('enable-multistream').checked) {
                    await startMultiStream();
                }
                
                // Update state
                APP_STATE.streaming = true;
                APP_STATE.startTime = Date.now();
                
                // Update UI
                document.getElementById('start-stream-btn').disabled = true;
                document.getElementById('stop-stream-btn').disabled = false;
                document.getElementById('status-text').textContent = 'Live';
                document.getElementById('connection-status').classList.add('active');
                document.getElementById('preview-status').textContent = 'ğŸ”´ LIVE';
                
                // Start timers and health checks
                startStreamTimer();
                streamingEngine.startHealthChecks();
                networkMonitor.start();
                
                showToast('ğŸ‰ Stream started! You\'re LIVE!', 'success');
                
                // Award currency for starting stream
                const role = APP_STATE.role ? ROLES[APP_STATE.role] : null;
                if (role) {
                    awardCurrency(role.primaryCurrency.baseRate, role.secondaryCurrency.baseRate, 'for starting stream');
                } else {
                    awardCurrency(10, 5, 'for starting stream');
                }
                
                // Save to history (prepare data)
                APP_STATE.currentStreamData = {
                    timestamp: APP_STATE.startTime,
                    platform: APP_STATE.rtmpSettings.platform,
                    protocol: protocol,
                    resolution: APP_STATE.streamSettings.resolution,
                    bitrate: APP_STATE.streamSettings.videoBitrate
                };
                
            } catch (error) {
                console.error('Error starting stream:', error);
                showToast(`Failed to start stream: ${error.message}`, 'error');
                streamingEngine.stopAll();
            }
        }
        
        async function startMultiStream() {
            // Start additional streams to other destinations
            const destinations = APP_STATE.multistreamDestinations || [];
            
            for (const dest of destinations) {
                if (!dest.enabled) continue;
                
                try {
                    switch (dest.protocol) {
                        case 'webrtc-whip':
                            await streamingEngine.startWebRTCWHIP(dest.url, dest.key, APP_STATE.mediaStream);
                            break;
                        case 'websocket':
                            await streamingEngine.startWebSocketStream(dest.url, dest.key, APP_STATE.mediaStream);
                            break;
                        case 'hls-upload':
                            await streamingEngine.startHLSUpload(dest.url, dest.key, APP_STATE.mediaStream);
                            break;
                        case 'rtmp-relay':
                            await streamingEngine.startRTMPRelay(dest.url, dest.key, APP_STATE.mediaStream);
                            break;
                    }
                    showToast(`Connected to ${dest.name}`, 'success');
                } catch (error) {
                    showToast(`Failed to connect to ${dest.name}: ${error.message}`, 'error');
                }
            }
        }
        
        function stopStream() {
            if (APP_STATE.streaming) {
                streamingEngine.stopAll();
                networkMonitor.stop();
                
                APP_STATE.streaming = false;
                
                // Update UI
                document.getElementById('start-stream-btn').disabled = false;
                document.getElementById('stop-stream-btn').disabled = true;
                document.getElementById('status-text').textContent = 'Offline';
                document.getElementById('connection-status').classList.remove('active');
                document.getElementById('preview-status').textContent = 'âš« Not Streaming';
                
                // Stop timer
                if (APP_STATE.timerInterval) {
                    clearInterval(APP_STATE.timerInterval);
                }
                
                // Calculate duration and save to history
                if (APP_STATE.currentStreamData) {
                    APP_STATE.currentStreamData.duration = APP_STATE.elapsedTime;
                    APP_STATE.currentStreamData.category = APP_STATE.activeStreamCategory;
                    
                    saveToStore('streams', APP_STATE.currentStreamData).then(() => {
                        loadHistory();
                        trackAnalytics(APP_STATE.currentStreamData);
                    });
                }
                
                // Complete Habitica task
                await completeHabiticaStreamingTask();
                
                // Award currency based on duration
                const durationMinutes = Math.floor(APP_STATE.elapsedTime / 60);
                const role = APP_STATE.role ? ROLES[APP_STATE.role] : null;
                if (role) {
                    const primaryAward = durationMinutes * role.primaryCurrency.baseRate;
                    const secondaryAward = durationMinutes * role.secondaryCurrency.baseRate;
                    awardCurrency(primaryAward, secondaryAward, `for streaming ${durationMinutes} minutes`);
                } else {
                    awardCurrency(durationMinutes * 5, durationMinutes * 2, '');
                }
                
                showToast('Stream stopped', 'success');
                
                // Check achievements
                checkAchievements();
            }
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           STREAM TIMER
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        
        function startStreamTimer() {
            APP_STATE.timerInterval = setInterval(() => {
                APP_STATE.elapsedTime = Math.floor((Date.now() - APP_STATE.startTime) / 1000);
                updateStreamTimeDisplay();
                
                // Award currency every minute
                if (APP_STATE.elapsedTime % 60 === 0 && APP_STATE.elapsedTime > 0) {
                    const role = APP_STATE.role ? ROLES[APP_STATE.role] : null;
                    if (role) {
                        awardCurrency(role.primaryCurrency.baseRate, role.secondaryCurrency.baseRate, '');
                    } else {
                        awardCurrency(5, 2, '');
                    }
                }
            }, 1000);
        }
        
        function updateStreamTimeDisplay() {
            const hours = Math.floor(APP_STATE.elapsedTime / 3600);
            const minutes = Math.floor((APP_STATE.elapsedTime % 3600) / 60);
            const seconds = APP_STATE.elapsedTime % 60;
            
            document.getElementById('stream-time').textContent = 
                `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ROLE-BASED CURRENCY & PROGRESSION SYSTEM
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Award currencies based on role, actions, and bonuses
           Usage: Automatic awards during streaming, manual awards for milestones
        */
        
        function awardCurrency(primaryAmount, secondaryAmount, reason = '') {
            if (!APP_STATE.role) {
                showToast('âš ï¸ Select a role first to earn rewards!', 'warning');
                return;
            }
            
            const role = ROLES[APP_STATE.role];
            
            // Apply role-specific bonuses
            let primaryMultiplier = 1;
            let secondaryMultiplier = 1;
            
            // Example bonus logic (can be extended)
            if (APP_STATE.streamSettings.framerate === 60 && role.bonuses.highFPS) {
                primaryMultiplier *= role.bonuses.highFPS;
            }
            
            const finalPrimary = Math.floor(primaryAmount * primaryMultiplier);
            const finalSecondary = Math.floor(secondaryAmount * secondaryMultiplier);
            
            APP_STATE.currencies.primary += finalPrimary;
            APP_STATE.currencies.secondary += finalSecondary;
            
            updateCurrencyDisplay();
            
            // Check for level up
            checkLevelUp();
            
            // Save to IndexedDB
            saveToStore('settings', { key: 'currencies', value: APP_STATE.currencies });
            
            if (reason && finalPrimary > 0) {
                showToast(`ğŸ’° +${finalPrimary} ${role.primaryCurrency.icon} ${reason}`, 'success');
            }
        }
        
        function updateCurrencyDisplay() {
            if (!APP_STATE.role) return;
            
            const role = ROLES[APP_STATE.role];
            
            document.getElementById('currency-primary-label').textContent = role.primaryCurrency.name;
            document.getElementById('currency-primary-value').innerHTML = 
                `${role.primaryCurrency.icon} ${APP_STATE.currencies.primary.toLocaleString()}`;
            
            document.getElementById('currency-secondary-label').textContent = role.secondaryCurrency.name;
            document.getElementById('currency-secondary-value').innerHTML = 
                `${role.secondaryCurrency.icon} ${APP_STATE.currencies.secondary.toLocaleString()}`;
        }
        
        function checkLevelUp() {
            if (!APP_STATE.role) return;
            
            const role = ROLES[APP_STATE.role];
            const requiredPrimary = APP_STATE.level * 100;
            
            if (APP_STATE.currencies.primary >= requiredPrimary) {
                APP_STATE.level++;
                
                const titleIndex = Math.min(Math.floor(APP_STATE.level / 10), role.levelTitles.length - 1);
                const title = role.levelTitles[titleIndex];
                
                document.getElementById('level-count').textContent = APP_STATE.level;
                document.getElementById('role-display').textContent = `${role.icon} ${title}`;
                
                showToast(`ğŸ‰ Level Up! You're now level ${APP_STATE.level}!`, 'success');
                showToast(`âœ¨ New title: ${title}`, 'success');
                
                // Award bonus currencies on level up
                awardCurrency(50, 25, 'for leveling up!');
                
                saveToStore('settings', { key: 'level', value: APP_STATE.level });
            }
        }
        
        function selectRole(roleName) {
            APP_STATE.role = roleName;
            const role = ROLES[roleName];
            
            // Update UI theme
            document.body.dataset.role = roleName;
            
            // Update role display
            document.getElementById('role-display').textContent = `${role.icon} ${role.levelTitles[0]}`;
            
            // Update currency displays
            updateCurrencyDisplay();
            
            // Close modal
            document.getElementById('role-modal').style.display = 'none';
            
            // Save role
            saveToStore('settings', { key: 'role', value: roleName });
            
            showToast(`ğŸ­ Welcome, ${role.name}!`, 'success');
            showToast(`You now earn ${role.primaryCurrency.icon} ${role.primaryCurrency.name} and ${role.secondaryCurrency.icon} ${role.secondaryCurrency.name}!`, 'success');
            
            // Award starting bonus
            awardCurrency(25, 10, 'as a welcome bonus!');
        }
        
        function openRoleModal() {
            document.getElementById('role-modal').style.display = 'block';
        }
        
        function closeRoleModal() {
            document.getElementById('role-modal').style.display = 'none';
        }
        
        // Old awardXP function replaced with awardCurrency
        function awardXP(amount) {
            // Legacy support - convert to currency system
            const role = APP_STATE.role ? ROLES[APP_STATE.role] : null;
            if (role) {
                awardCurrency(amount * 2, amount, '');
            }
        }
        
        const ACHIEVEMENTS = [
            { id: 'first_stream', icon: 'ğŸ¬', title: 'First Stream', desc: 'Complete your first stream', condition: () => APP_STATE.streamHistory.length >= 1 },
            { id: 'five_streams', icon: 'ğŸŒŸ', title: 'Getting Started', desc: 'Complete 5 streams', condition: () => APP_STATE.streamHistory.length >= 5 },
            { id: 'marathon', icon: 'â°', title: 'Marathon Streamer', desc: 'Stream for over 1 hour', condition: () => APP_STATE.streamHistory.some(s => s.duration > 3600) },
            { id: 'consistent', icon: 'ğŸ“…', title: 'Consistency is Key', desc: 'Stream 3 days in a row', condition: checkConsistency },
            { id: 'level_5', icon: 'â­', title: 'Rising Star', desc: 'Reach level 5', condition: () => APP_STATE.level >= 5 },
            { id: 'level_10', icon: 'ğŸ’«', title: 'Streaming Pro', desc: 'Reach level 10', condition: () => APP_STATE.level >= 10 },
            { id: 'hd_quality', icon: 'ğŸ¥', title: 'HD Quality', desc: 'Stream in 1080p', condition: () => APP_STATE.streamSettings.resolution === '1920x1080' },
            { id: 'multi_platform', icon: 'ğŸŒ', title: 'Multi-Platform', desc: 'Stream to 3 different platforms', condition: checkMultiPlatform }
        ];
        
        function checkConsistency() {
            if (APP_STATE.streamHistory.length < 3) return false;
            
            const dates = APP_STATE.streamHistory.map(s => {
                const date = new Date(s.timestamp);
                return `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
            });
            
            const uniqueDates = [...new Set(dates)].sort();
            
            // Check for 3 consecutive dates
            for (let i = 0; i < uniqueDates.length - 2; i++) {
                const date1 = new Date(uniqueDates[i]);
                const date2 = new Date(uniqueDates[i + 1]);
                const date3 = new Date(uniqueDates[i + 2]);
                
                const diff1 = (date2 - date1) / (1000 * 60 * 60 * 24);
                const diff2 = (date3 - date2) / (1000 * 60 * 60 * 24);
                
                if (diff1 === 1 && diff2 === 1) return true;
            }
            
            return false;
        }
        
        function checkMultiPlatform() {
            const platforms = new Set(APP_STATE.streamHistory.map(s => s.platform));
            return platforms.size >= 3;
        }
        
        async function checkAchievements() {
            for (const achievement of ACHIEVEMENTS) {
                // Skip if already unlocked
                if (APP_STATE.achievements.includes(achievement.id)) continue;
                
                // Check condition
                if (achievement.condition()) {
                    APP_STATE.achievements.push(achievement.id);
                    await saveToStore('achievements', { id: achievement.id, unlockedAt: Date.now() });
                    
                    showToast(`ğŸ† Achievement Unlocked: ${achievement.title}!`, 'success');
                    
                    // Award bonus XP
                    awardXP(50);
                    
                    // Update achievement display
                    renderAchievements();
                }
            }
        }
        
        function renderAchievements() {
            const grid = document.getElementById('achievement-grid');
            grid.innerHTML = '';
            
            ACHIEVEMENTS.forEach(achievement => {
                const unlocked = APP_STATE.achievements.includes(achievement.id);
                
                const card = document.createElement('div');
                card.className = 'achievement' + (unlocked ? ' unlocked' : '');
                card.innerHTML = `
                    <div class="achievement-icon">${achievement.icon}</div>
                    <div class="achievement-title">${achievement.title}</div>
                    <div class="achievement-desc">${achievement.desc}</div>
                `;
                
                grid.appendChild(card);
            });
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RTMP CONFIGURATION
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        
        const PLATFORM_PRESETS = {
            twitch: {
                name: 'Twitch',
                protocols: {
                    'rtmp-relay': 'rtmp://live.twitch.tv/app/',
                    'webrtc-whip': 'https://video-ingest.twitch.tv/whip',
                    'websocket': 'wss://relay.example.com/twitch'
                },
                keyPlaceholder: 'live_XXXXXXXXXXXX_XXXXXXXXXXXXXXXXXXXXXXXX',
                docs: 'https://dev.twitch.tv/docs/video-broadcast/'
            },
            youtube: {
                name: 'YouTube',
                protocols: {
                    'rtmp-relay': 'rtmp://a.rtmp.youtube.com/live2/',
                    'hls-upload': 'https://www.googleapis.com/upload/youtube/v3/liveStreams',
                    'websocket': 'wss://relay.example.com/youtube'
                },
                keyPlaceholder: 'xxxx-xxxx-xxxx-xxxx-xxxx',
                docs: 'https://developers.google.com/youtube/v3/live'
            },
            facebook: {
                name: 'Facebook',
                protocols: {
                    'rtmp-relay': 'rtmps://live-api-s.facebook.com:443/rtmp/',
                    'webrtc-whip': 'https://streaming-graph.facebook.com/whip',
                    'websocket': 'wss://relay.example.com/facebook'
                },
                keyPlaceholder: 'FB-XXXXXXXXXXXXXXXXXXXX',
                docs: 'https://developers.facebook.com/docs/live-video-api'
            },
            custom: {
                name: 'Custom',
                protocols: {
                    'webrtc-whip': 'https://your-server.com/whip',
                    'websocket': 'wss://your-server.com/stream',
                    'hls-upload': 'https://your-server.com/hls-ingest',
                    'rtmp-relay': 'rtmp://your-server.com/live',
                    'srt-websocket': 'wss://your-server.com/srt'
                },
                keyPlaceholder: 'Enter your stream key',
                docs: ''
            }
        };
        
        function selectPlatform(platform) {
            const preset = PLATFORM_PRESETS[platform];
            const currentProtocol = document.getElementById('streaming-protocol').value;
            
            // Set URL based on selected protocol
            const url = preset.protocols[currentProtocol] || Object.values(preset.protocols)[0];
            document.getElementById('rtmp-url').value = url;
            document.getElementById('stream-key').placeholder = preset.keyPlaceholder;
            
            APP_STATE.rtmpSettings.platform = platform;
            
            // Update UI
            document.querySelectorAll('.platform-card').forEach(card => {
                card.classList.remove('selected');
            });
            event.target.closest('.platform-card').classList.add('selected');
            
            showToast(`Platform set to ${preset.name}`, 'success');
        }
        
        function handleProtocolChange() {
            const protocol = document.getElementById('streaming-protocol').value;
            const urlLabel = document.getElementById('url-label');
            const urlHint = document.getElementById('url-hint');
            const protocolHint = document.getElementById('protocol-hint');
            
            const hints = {
                'webrtc-whip': {
                    label: 'WHIP Endpoint URL',
                    hint: 'Example: https://your-server.com/whip',
                    description: 'Modern WebRTC protocol with sub-second latency'
                },
                'websocket': {
                    label: 'WebSocket Server URL',
                    hint: 'Example: wss://your-server.com/stream',
                    description: 'Real-time binary streaming over WebSocket'
                },
                'hls-upload': {
                    label: 'HLS Ingest Endpoint',
                    hint: 'Example: https://your-server.com/hls-ingest',
                    description: 'Upload HLS segments for universal compatibility'
                },
                'rtmp-relay': {
                    label: 'RTMP Relay URL',
                    hint: 'Example: rtmp://your-server.com/live',
                    description: 'RTMP via WebSocket relay server'
                },
                'srt-websocket': {
                    label: 'SRT WebSocket Bridge',
                    hint: 'Example: wss://your-server.com/srt',
                    description: 'Secure Reliable Transport via WebSocket'
                }
            };
            
            const config = hints[protocol];
            urlLabel.textContent = config.label;
            urlHint.textContent = config.hint;
            protocolHint.textContent = config.description;
            
            // Update URL if platform is selected
            const platform = APP_STATE.rtmpSettings.platform;
            if (platform && PLATFORM_PRESETS[platform]) {
                const preset = PLATFORM_PRESETS[platform];
                const url = preset.protocols[protocol];
                if (url) {
                    document.getElementById('rtmp-url').value = url;
                }
            }
        }
        
        async function saveRTMPSettings() {
            const url = document.getElementById('rtmp-url').value.trim();
            const key = document.getElementById('stream-key').value.trim();
            
            if (!url || !key) {
                showToast('Please fill in both RTMP URL and Stream Key', 'warning');
                return;
            }
            
            APP_STATE.rtmpSettings.url = url;
            APP_STATE.rtmpSettings.key = key;
            
            await saveToStore('settings', { key: 'rtmp', value: APP_STATE.rtmpSettings });
            
            showToast('RTMP settings saved!', 'success');
        }
        
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           MULTI-STREAM MANAGEMENT
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        
        APP_STATE.multistreamDestinations = [];
        
        function addDestination() {
            const id = Date.now();
            const destination = {
                id: id,
                name: `Destination ${APP_STATE.multistreamDestinations.length + 1}`,
                protocol: 'webrtc-whip',
                url: '',
                key: '',
                enabled: true
            };
            
            APP_STATE.multistreamDestinations.push(destination);
            renderMultistreamDestinations();
            saveToStore('settings', { key: 'multistream', value: APP_STATE.multistreamDestinations });
        }
        
        function removeDestination(id) {
            APP_STATE.multistreamDestinations = APP_STATE.multistreamDestinations.filter(d => d.id !== id);
            renderMultistreamDestinations();
            saveToStore('settings', { key: 'multistream', value: APP_STATE.multistreamDestinations });
        }
        
        function updateDestination(id, field, value) {
            const dest = APP_STATE.multistreamDestinations.find(d => d.id === id);
            if (dest) {
                dest[field] = value;
                saveToStore('settings', { key: 'multistream', value: APP_STATE.multistreamDestinations });
            }
        }
        
        function renderMultistreamDestinations() {
            const container = document.getElementById('multistream-destinations');
            container.innerHTML = '';
            
            APP_STATE.multistreamDestinations.forEach((dest, index) => {
                const destDiv = document.createElement('div');
                destDiv.style.cssText = 'background: var(--background); padding: 1rem; border-radius: 8px; margin-bottom: 1rem; border: 1px solid var(--border);';
                destDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                        <input type="text" value="${dest.name}" 
                               onchange="updateDestination(${dest.id}, 'name', this.value)"
                               style="width: 200px; padding: 0.5rem; background: var(--surface); border: 1px solid var(--border); border-radius: 4px; color: var(--text);">
                        <label style="display: flex; align-items: center; gap: 0.5rem;">
                            <input type="checkbox" ${dest.enabled ? 'checked' : ''} 
                                   onchange="updateDestination(${dest.id}, 'enabled', this.checked)"
                                   style="width: auto;">
                            Enabled
                        </label>
                        <button class="btn btn-danger" onclick="removeDestination(${dest.id})" style="padding: 0.5rem 1rem;">
                            ğŸ—‘ï¸ Remove
                        </button>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                        <select onchange="updateDestination(${dest.id}, 'protocol', this.value)"
                                style="padding: 0.5rem; background: var(--surface); border: 1px solid var(--border); border-radius: 4px; color: var(--text);">
                            <option value="webrtc-whip" ${dest.protocol === 'webrtc-whip' ? 'selected' : ''}>WebRTC-WHIP</option>
                            <option value="websocket" ${dest.protocol === 'websocket' ? 'selected' : ''}>WebSocket</option>
                            <option value="hls-upload" ${dest.protocol === 'hls-upload' ? 'selected' : ''}>HLS Upload</option>
                            <option value="rtmp-relay" ${dest.protocol === 'rtmp-relay' ? 'selected' : ''}>RTMP Relay</option>
                        </select>
                        <input type="text" placeholder="URL" value="${dest.url}"
                               onchange="updateDestination(${dest.id}, 'url', this.value)"
                               style="padding: 0.5rem; background: var(--surface); border: 1px solid var(--border); border-radius: 4px; color: var(--text);">
                    </div>
                    <input type="password" placeholder="Stream Key / Token" value="${dest.key}"
                           onchange="updateDestination(${dest.id}, 'key', this.value)"
                           style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: var(--surface); border: 1px solid var(--border); border-radius: 4px; color: var(--text);">
                `;
                container.appendChild(destDiv);
            });
        }
        
        // Toggle multistream UI
        document.addEventListener('DOMContentLoaded', () => {
            const multistreamCheckbox = document.getElementById('enable-multistream');
            if (multistreamCheckbox) {
                multistreamCheckbox.addEventListener('change', (e) => {
                    const container = document.getElementById('multistream-container');
                    container.style.display = e.target.checked ? 'block' : 'none';
                });
            }
        });
        
        async function testConnection() {
            const protocol = document.getElementById('streaming-protocol').value;
            const url = document.getElementById('rtmp-url').value;
            const key = document.getElementById('stream-key').value;
            
            if (!url || !key) {
                showToast('Please fill in URL and authentication credentials', 'warning');
                return;
            }
            
            showToast('Testing connection...', 'warning');
            
            try {
                // Attempt a simple connection test based on protocol
                switch (protocol) {
                    case 'webrtc-whip':
                    case 'hls-upload':
                        // Test HTTP endpoint
                        const response = await fetch(url, {
                            method: 'OPTIONS',
                            headers: {
                                'Authorization': `Bearer ${key}`
                            }
                        });
                        
                        if (response.ok || response.status === 405) {
                            showToast('âœ… Connection test successful!', 'success');
                        } else {
                            showToast(`âš ï¸ Server responded with status ${response.status}`, 'warning');
                        }
                        break;
                        
                    case 'websocket':
                    case 'rtmp-relay':
                    case 'srt-websocket':
                        // Test WebSocket connection
                        const ws = new WebSocket(url);
                        
                        ws.onopen = () => {
                            showToast('âœ… Connection test successful!', 'success');
                            ws.close();
                        };
                        
                        ws.onerror = () => {
                            showToast('âŒ Connection test failed', 'error');
                        };
                        
                        setTimeout(() => {
                            if (ws.readyState !== WebSocket.OPEN) {
                                showToast('âŒ Connection timeout', 'error');
                                ws.close();
                            }
                        }, 5000);
                        break;
                }
                
            } catch (error) {
                showToast(`âŒ Connection test failed: ${error.message}`, 'error');
            }
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           STREAM HISTORY
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        
        async function loadHistory() {
            const streams = await getAllFromStore('streams');
            APP_STATE.streamHistory = streams.sort((a, b) => b.timestamp - a.timestamp);
            
            renderHistory();
        }
        
        function renderHistory() {
            const list = document.getElementById('history-list');
            
            if (APP_STATE.streamHistory.length === 0) {
                list.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: var(--text-dim);">
                        No streams yet. Start your first stream to build your history!
                    </div>
                `;
                return;
            }
            
            list.innerHTML = '';
            
            APP_STATE.streamHistory.forEach((stream, index) => {
                const date = new Date(stream.timestamp);
                const duration = formatDuration(stream.duration);
                const size = formatBytes(stream.size || 0);
                
                const item = document.createElement('div');
                item.className = 'history-item';
                item.innerHTML = `
                    <div class="history-info">
                        <div class="history-title">
                            ${PLATFORM_PRESETS[stream.platform]?.name || 'Custom'} Stream
                        </div>
                        <div class="history-meta">
                            ${date.toLocaleString()} â€¢ ${duration} â€¢ ${stream.resolution} â€¢ ${size}
                        </div>
                    </div>
                    <div class="history-actions">
                        <button class="btn btn-secondary" onclick="deleteStream(${stream.id})" style="padding: 0.5rem;">
                            ğŸ—‘ï¸
                        </button>
                    </div>
                `;
                
                list.appendChild(item);
            });
        }
        
        async function deleteStream(id) {
            if (!confirm('Delete this stream from history?')) return;
            
            const transaction = db.transaction(['streams'], 'readwrite');
            const store = transaction.objectStore('streams');
            await store.delete(id);
            
            await loadHistory();
            showToast('Stream deleted from history', 'success');
        }
        
        async function clearHistory() {
            if (!confirm('Clear all stream history? This cannot be undone.')) return;
            
            const transaction = db.transaction(['streams'], 'readwrite');
            const store = transaction.objectStore('streams');
            await store.clear();
            
            APP_STATE.streamHistory = [];
            renderHistory();
            
            showToast('History cleared', 'success');
        }
        
        async function exportHistory() {
            const data = {
                streams: APP_STATE.streamHistory,
                exportDate: new Date().toISOString(),
                version: '1.0'
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `stream-history-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('History exported!', 'success');
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ANALYTICS (PRIVACY-RESPECTING)
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Track usage patterns for improvement, no PII
           Usage: Daily summaries sent to admin email
           Expected: Aggregated data only, opt-out available
        */
        
        async function trackAnalytics(streamData) {
            const today = new Date().toISOString().split('T')[0];
            
            let dayData = await loadFromStore('analytics', today);
            
            if (!dayData) {
                dayData = {
                    date: today,
                    streamCount: 0,
                    totalDuration: 0,
                    platformCounts: {},
                    resolutionCounts: {}
                };
            }
            
            dayData.streamCount++;
            dayData.totalDuration += streamData.duration;
            dayData.platformCounts[streamData.platform] = (dayData.platformCounts[streamData.platform] || 0) + 1;
            dayData.resolutionCounts[streamData.resolution] = (dayData.resolutionCounts[streamData.resolution] || 0) + 1;
            
            await saveToStore('analytics', dayData);
            
            // Note: Actual email sending would require server-side implementation
            // This is a placeholder for the privacy notice
            console.log('Analytics tracked:', dayData);
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           UI UTILITIES
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        
        function showToast(message, type = 'success') {
            const container = document.getElementById('toast-container');
            
            const icons = {
                success: 'âœ…',
                error: 'âŒ',
                warning: 'âš ï¸'
            };
            
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <div class="toast-icon">${icons[type]}</div>
                <div>${message}</div>
            `;
            
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s reverse';
                setTimeout(() => toast.remove(), 300);
            }, 4000);
        }
        
        function formatDuration(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = seconds % 60;
            
            if (h > 0) return `${h}h ${m}m ${s}s`;
            if (m > 0) return `${m}m ${s}s`;
            return `${s}s`;
        }
        
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           COLLAPSIBLE SECTIONS
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        
        function initCollapsibleSections() {
            document.querySelectorAll('.section-header').forEach(header => {
                header.addEventListener('click', () => {
                    const section = header.parentElement;
                    section.classList.toggle('collapsed');
                    
                    // Save state to localStorage
                    const sectionId = section.dataset.section;
                    const collapsed = section.classList.contains('collapsed');
                    localStorage.setItem(`section-${sectionId}-collapsed`, collapsed);
                });
            });
            
            // Restore saved states
            document.querySelectorAll('.section').forEach(section => {
                const sectionId = section.dataset.section;
                const collapsed = localStorage.getItem(`section-${sectionId}-collapsed`) === 'true';
                if (collapsed) {
                    section.classList.add('collapsed');
                }
            });
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ROLE SYSTEM INITIALIZATION
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        
        function initRoleSystem() {
            // Check for saved role
            const savedRole = localStorage.getItem('role');
            
            if (savedRole && ROLES[savedRole]) {
                APP_STATE.role = savedRole;
                document.body.dataset.role = savedRole;
                
                const role = ROLES[savedRole];
                const titleIndex = Math.min(Math.floor(APP_STATE.level / 10), role.levelTitles.length - 1);
                document.getElementById('role-display').textContent = `${role.icon} ${role.levelTitles[titleIndex]}`;
                
                updateCurrencyDisplay();
                
                // Set active role button
                document.querySelectorAll('[data-role]').forEach(btn => {
                    if (btn.dataset.role === savedRole) {
                        btn.classList.add('active');
                        btn.style.transform = 'scale(1.2)';
                        btn.style.borderWidth = '3px';
                    }
                });
            } else {
                // Show role selection modal on first load
                setTimeout(() => {
                    openRoleModal();
                }, 1000);
            }
            
            // Setup role card click handlers
            document.querySelectorAll('.role-card').forEach(card => {
                card.addEventListener('click', () => {
                    const role = card.dataset.role;
                    selectRole(role);
                });
                
                card.addEventListener('mouseenter', () => {
                    card.style.transform = 'translateY(-8px) scale(1.02)';
                    card.style.boxShadow = '0 12px 40px rgba(0, 0, 0, 0.5)';
                });
                
                card.addEventListener('mouseleave', () => {
                    card.style.transform = 'translateY(0) scale(1)';
                    card.style.boxShadow = 'none';
                });
            });
            
            // Setup role button handlers in header
            document.querySelectorAll('.theme-btn[data-role]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const role = btn.dataset.role;
                    
                    if (APP_STATE.role === role) {
                        // Already selected, show info
                        const roleData = ROLES[role];
                        showToast(`Current role: ${roleData.name}`, 'success');
                        return;
                    }
                    
                    // Confirm role change
                    if (APP_STATE.role && !confirm(`Change role from ${ROLES[APP_STATE.role].name} to ${ROLES[role].name}? This will reset your progress.`)) {
                        return;
                    }
                    
                    // Reset progress for role change
                    if (APP_STATE.role) {
                        APP_STATE.currencies.primary = 0;
                        APP_STATE.currencies.secondary = 0;
                        APP_STATE.level = 1;
                    }
                    
                    selectRole(role);
                    
                    // Update active button
                    document.querySelectorAll('.theme-btn').forEach(b => {
                        b.classList.remove('active');
                        b.style.transform = 'scale(1)';
                        b.style.borderWidth = '2px';
                    });
                    btn.classList.add('active');
                    btn.style.transform = 'scale(1.2)';
                    btn.style.borderWidth = '3px';
                });
            });
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           EXPORT FUNCTIONS
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        
        function exportAsHTML() {
            const html = document.documentElement.outerHTML;
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'stream-sanctuary.html';
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('HTML exported!', 'success');
        }
        
        async function exportAsJSON() {
            const data = {
                settings: APP_STATE.streamSettings,
                xp: APP_STATE.xp,
                level: APP_STATE.level,
                achievements: APP_STATE.achievements,
                streamHistory: APP_STATE.streamHistory,
                exportDate: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `stream-sanctuary-data-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('Data exported!', 'success');
        }
        
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           MNEMONIC/SPACED REPETITION SYSTEM (SM-2 Algorithm)
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Flashcard learning with optimal review scheduling
           Algorithm: SuperMemo SM-2 for calculating review intervals
           Usage: Study between streams, earn bonus currencies for reviews
        */
        
        class MnemonicSystem {
            constructor() {
                this.decks = [];
                this.reviewSession = null;
            }
            
            // SM-2 Algorithm for calculating next review interval
            calculateNextReview(card, quality) {
                // quality: 0-5 scale (0=wrong, 5=perfect)
                let easiness = card.easiness || 2.5;
                let interval = card.interval || 0;
                let repetitions = card.repetitions || 0;
                
                if (quality < 3) {
                    // Failed - reset to beginning
                    repetitions = 0;
                    interval = 1;
                } else {
                    // Passed - increase interval
                    easiness = easiness + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
                    easiness = Math.max(1.3, easiness);
                    
                    if (repetitions === 0) {
                        interval = 1;
                    } else if (repetitions === 1) {
                        interval = 6;
                    } else {
                        interval = Math.round(interval * easiness);
                    }
                    
                    repetitions++;
                }
                
                const nextReview = new Date();
                nextReview.setDate(nextReview.getDate() + interval);
                
                return {
                    easiness: easiness,
                    interval: interval,
                    repetitions: repetitions,
                    nextReview: nextReview.getTime()
                };
            }
            
            async loadDecks() {
                this.decks = await getAllFromStore('decks');
                return this.decks;
            }
            
            async getDueCards() {
                const allCards = await getAllFromStore('mnemonics');
                const now = Date.now();
                return allCards.filter(card => card.nextReview <= now);
            }
            
            async reviewCard(cardId, quality) {
                const card = await loadFromStore('mnemonics', cardId);
                const updates = this.calculateNextReview(card, quality);
                
                Object.assign(card, updates);
                await saveToStore('mnemonics', card);
                
                // Award currency for reviewing
                if (APP_STATE.role) {
                    const role = ROLES[APP_STATE.role];
                    awardCurrency(role.primaryCurrency.baseRate * 0.5, role.secondaryCurrency.baseRate * 0.5, 'for review');
                }
                
                return card;
            }
            
            async createDeck(name, description) {
                const deck = {
                    name: name,
                    description: description,
                    created: Date.now(),
                    cardCount: 0
                };
                
                const id = await saveToStore('decks', deck);
                deck.id = id;
                
                return deck;
            }
            
            async addCard(deckId, front, back, hint = '') {
                const card = {
                    deckId: deckId,
                    front: front,
                    back: back,
                    hint: hint,
                    easiness: 2.5,
                    interval: 0,
                    repetitions: 0,
                    nextReview: Date.now(),
                    created: Date.now()
                };
                
                const id = await saveToStore('mnemonics', card);
                card.id = id;
                
                // Update deck card count
                const deck = await loadFromStore('decks', deckId);
                deck.cardCount = (deck.cardCount || 0) + 1;
                await saveToStore('decks', deck);
                
                return card;
            }
            
            async importAnkiCSV(csvText, deckId) {
                const lines = csvText.split('\n');
                let imported = 0;
                
                for (const line of lines) {
                    if (line.trim() === '') continue;
                    
                    const parts = line.split('\t');
                    if (parts.length >= 2) {
                        await this.addCard(deckId, parts[0].trim(), parts[1].trim());
                        imported++;
                    }
                }
                
                return imported;
            }
        }
        
        const mnemonicSystem = new MnemonicSystem();
        
        async function startMnemonicReview() {
            const dueCards = await mnemonicSystem.getDueCards();
            
            if (dueCards.length === 0) {
                showToast('No cards due for review! ğŸ‰', 'success');
                return;
            }
            
            // Create review modal
            const modal = document.createElement('div');
            modal.id = 'review-modal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 10001; display: flex; align-items: center; justify-content: center;';
            
            let currentIndex = 0;
            let showingAnswer = false;
            
            function renderCard() {
                const card = dueCards[currentIndex];
                const progress = `${currentIndex + 1} / ${dueCards.length}`;
                
                modal.innerHTML = `
                    <div style="background: var(--surface); border-radius: 16px; padding: 3rem; max-width: 600px; width: 90%;">
                        <div style="text-align: right; color: var(--text-dim); margin-bottom: 1rem;">${progress}</div>
                        
                        <div style="min-height: 200px; display: flex; align-items: center; justify-content: center; text-align: center; font-size: 1.5rem; margin-bottom: 2rem;">
                            ${showingAnswer ? card.back : card.front}
                        </div>
                        
                        ${showingAnswer ? `
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-bottom: 1rem;">
                                <button class="btn btn-danger" onclick="rateCard(0)" style="padding: 1rem;">
                                    âŒ Again
                                </button>
                                <button class="btn btn-warning" onclick="rateCard(3)" style="padding: 1rem;">
                                    ğŸ˜ Hard
                                </button>
                                <button class="btn btn-success" onclick="rateCard(5)" style="padding: 1rem;">
                                    âœ… Easy
                                </button>
                            </div>
                        ` : `
                            <button class="btn btn-primary" onclick="showAnswer()" style="width: 100%; padding: 1rem; font-size: 1.2rem;">
                                Show Answer
                            </button>
                        `}
                        
                        <button class="btn btn-secondary" onclick="closeReview()" style="width: 100%; margin-top: 1rem;">
                            Exit Review
                        </button>
                    </div>
                `;
            }
            
            window.showAnswer = () => {
                showingAnswer = true;
                renderCard();
            };
            
            window.rateCard = async (quality) => {
                const card = dueCards[currentIndex];
                await mnemonicSystem.reviewCard(card.id, quality);
                
                currentIndex++;
                showingAnswer = false;
                
                if (currentIndex >= dueCards.length) {
                    closeReview();
                    showToast(`ğŸ‰ Review complete! Reviewed ${dueCards.length} cards`, 'success');
                    await updateMnemonicStats();
                } else {
                    renderCard();
                }
            };
            
            window.closeReview = () => {
                document.body.removeChild(modal);
                delete window.showAnswer;
                delete window.rateCard;
                delete window.closeReview;
            };
            
            renderCard();
            document.body.appendChild(modal);
        }
        
        async function createMnemonicDeck() {
            const name = prompt('Deck name:');
            if (!name) return;
            
            const description = prompt('Description (optional):') || '';
            
            const deck = await mnemonicSystem.createDeck(name, description);
            showToast(`Created deck: ${name}`, 'success');
            
            await loadMnemonicDecks();
        }
        
        async function importAnkiDeck() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.txt,.csv';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const deckName = prompt('Deck name for import:');
                if (!deckName) return;
                
                const deck = await mnemonicSystem.createDeck(deckName, 'Imported from Anki');
                
                const text = await file.text();
                const imported = await mnemonicSystem.importAnkiCSV(text, deck.id);
                
                showToast(`Imported ${imported} cards into ${deckName}`, 'success');
                await loadMnemonicDecks();
            };
            
            input.click();
        }
        
        async function loadMnemonicDecks() {
            const decks = await mnemonicSystem.loadDecks();
            const container = document.getElementById('mnemonic-decks');
            
            if (decks.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-dim);">No decks yet. Create one to start learning!</div>';
                return;
            }
            
            container.innerHTML = '';
            
            for (const deck of decks) {
                const deckDiv = document.createElement('div');
                deckDiv.style.cssText = 'background: var(--background); padding: 1.5rem; border-radius: 12px; border: 1px solid var(--border); margin-bottom: 1rem;';
                
                const transaction = db.transaction(['mnemonics'], 'readonly');
                const store = transaction.objectStore('mnemonics');
                const index = store.index('deckId');
                const cards = await new Promise((resolve) => {
                    const request = index.getAll(IDBKeyRange.only(deck.id));
                    request.onsuccess = () => resolve(request.result);
                });
                
                const dueCards = cards.filter(c => c.nextReview <= Date.now());
                
                deckDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <h3 style="margin-bottom: 0.5rem; color: var(--primary);">${deck.name}</h3>
                            <div style="color: var(--text-dim); font-size: 0.9rem;">
                                ${cards.length} cards â€¢ ${dueCards.length} due for review
                            </div>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-primary" onclick="reviewDeck(${deck.id})" style="padding: 0.5rem 1rem;">
                                ğŸ“š Study
                            </button>
                            <button class="btn btn-secondary" onclick="addCardToDeck(${deck.id})" style="padding: 0.5rem 1rem;">
                                â• Add Card
                            </button>
                        </div>
                    </div>
                `;
                
                container.appendChild(deckDiv);
            }
        }
        
        window.reviewDeck = async (deckId) => {
            const transaction = db.transaction(['mnemonics'], 'readonly');
            const store = transaction.objectStore('mnemonics');
            const index = store.index('deckId');
            const cards = await new Promise((resolve) => {
                const request = index.getAll(IDBKeyRange.only(deckId));
                request.onsuccess = () => resolve(request.result);
            });
            
            const dueCards = cards.filter(c => c.nextReview <= Date.now());
            
            if (dueCards.length === 0) {
                showToast('No cards due in this deck!', 'success');
                return;
            }
            
            // Set temporary due cards and start review
            mnemonicSystem.reviewSession = { deckId, cards: dueCards };
            startMnemonicReview();
        };
        
        window.addCardToDeck = async (deckId) => {
            const front = prompt('Card front (question):');
            if (!front) return;
            
            const back = prompt('Card back (answer):');
            if (!back) return;
            
            await mnemonicSystem.addCard(deckId, front, back);
            showToast('Card added!', 'success');
            await loadMnemonicDecks();
        };
        
        async function updateMnemonicStats() {
            const dueCards = await mnemonicSystem.getDueCards();
            const decks = await mnemonicSystem.loadDecks();
            
            document.getElementById('reviews-due-count').textContent = dueCards.length;
            document.getElementById('active-decks-count').textContent = decks.length;
            
            // Calculate cards learned (cards with interval > 7 days)
            const allCards = await getAllFromStore('mnemonics');
            const learned = allCards.filter(c => c.interval > 7).length;
            document.getElementById('cards-learned-count').textContent = learned;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           HABITICA INTEGRATION API
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Sync streaming achievements with Habitica RPG platform
           Usage: Creates tasks, awards XP/gold, completes dailies
           Docs: https://habitica.com/apidoc/
        */
        
        class HabiticaAPI {
            constructor() {
                this.baseURL = 'https://habitica.com/api/v3';
                this.headers = {};
            }
            
            setCredentials(userId, apiToken) {
                this.headers = {
                    'Content-Type': 'application/json',
                    'x-api-user': userId,
                    'x-api-key': apiToken,
                    'x-client': 'stream-sanctuary-1.0.0'
                };
            }
            
            async request(method, endpoint, data = null) {
                try {
                    const options = {
                        method: method,
                        headers: this.headers
                    };
                    
                    if (data) {
                        options.body = JSON.stringify(data);
                    }
                    
                    const response = await fetch(`${this.baseURL}${endpoint}`, options);
                    
                    if (!response.ok) {
                        throw new Error(`Habitica API error: ${response.status}`);
                    }
                    
                    return await response.json();
                    
                } catch (error) {
                    console.error('Habitica API error:', error);
                    throw error;
                }
            }
            
            async getUser() {
                return await this.request('GET', '/user');
            }
            
            async createDailyTask(text, notes = '') {
                return await this.request('POST', '/tasks/user', {
                    text: text,
                    type: 'daily',
                    notes: notes,
                    priority: 1.5,
                    frequency: 'daily'
                });
            }
            
            async scoreTask(taskId, direction = 'up') {
                return await this.request('POST', `/tasks/${taskId}/score/${direction}`);
            }
            
            async getUserTasks(type = 'dailys') {
                return await this.request('GET', `/tasks/user?type=${type}`);
            }
            
            async awardUserPoints(hp = 0, exp = 0, mp = 0, gp = 0) {
                // Note: Direct stat modification requires admin access
                // Instead, we score tasks which awards XP/gold
                return { success: true, note: 'Use scoreTask for rewards' };
            }
        }
        
        const habiticaAPI = new HabiticaAPI();
        
        async function saveHabiticaSettings() {
            const enabled = document.getElementById('habitica-enabled').checked;
            const userId = document.getElementById('habitica-user-id').value.trim();
            const apiToken = document.getElementById('habitica-api-token').value.trim();
            
            if (enabled && (!userId || !apiToken)) {
                showToast('Please enter both User ID and API Token', 'warning');
                return;
            }
            
            APP_STATE.habitica = {
                enabled: enabled,
                userId: userId,
                apiToken: apiToken,
                syncEnabled: document.getElementById('habitica-sync-streams').checked,
                lastSync: null
            };
            
            if (enabled) {
                habiticaAPI.setCredentials(userId, apiToken);
            }
            
            await saveToStore('settings', { key: 'habitica', value: APP_STATE.habitica });
            
            showToast('Habitica settings saved!', 'success');
            
            if (enabled) {
                await testHabiticaConnection();
            }
        }
        
        async function testHabiticaConnection() {
            const statusDiv = document.getElementById('habitica-status');
            statusDiv.style.display = 'block';
            statusDiv.innerHTML = '<div style="text-align: center;">Testing connection...</div>';
            
            try {
                const userData = await habiticaAPI.getUser();
                
                statusDiv.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <div style="font-size: 3rem;">${userData.data.stats.class === 'warrior' ? 'âš”ï¸' : userData.data.stats.class === 'wizard' ? 'ğŸ§™' : userData.data.stats.class === 'rogue' ? 'ğŸ—¡ï¸' : 'ğŸ›¡ï¸'}</div>
                        <div style="flex: 1;">
                            <div style="font-size: 1.2rem; font-weight: 600; color: var(--success);">âœ… Connected Successfully!</div>
                            <div style="color: var(--text-dim); margin-top: 0.5rem;">
                                <strong>${userData.data.profile.name}</strong> â€¢ Level ${userData.data.stats.lvl} ${userData.data.stats.class || 'Adventurer'}
                            </div>
                            <div style="margin-top: 0.5rem; font-size: 0.9rem;">
                                <span style="color: var(--warning);">ğŸ’° ${Math.floor(userData.data.stats.gp)} Gold</span> â€¢ 
                                <span style="color: var(--primary);">âš¡ ${userData.data.stats.exp}/${userData.data.stats.toNextLevel} XP</span>
                            </div>
                        </div>
                    </div>
                `;
                
                showToast('Successfully connected to Habitica!', 'success');
                
            } catch (error) {
                statusDiv.innerHTML = `
                    <div style="color: var(--danger);">
                        âŒ Connection failed: ${error.message}
                        <div style="margin-top: 0.5rem; font-size: 0.9rem;">Check your User ID and API Token</div>
                    </div>
                `;
                showToast('Failed to connect to Habitica', 'error');
            }
        }
        
        async function syncHabitica() {
            if (!APP_STATE.habitica.enabled) {
                showToast('Enable Habitica integration first', 'warning');
                return;
            }
            
            try {
                // Create streaming daily task if it doesn't exist
                const tasks = await habiticaAPI.getUserTasks('dailys');
                const streamingTask = tasks.data.find(t => t.text.includes('Stream Content'));
                
                if (!streamingTask && document.getElementById('habitica-sync-streams').checked) {
                    await habiticaAPI.createDailyTask(
                        'ğŸ¥ Stream Content',
                        'Complete at least one streaming session today'
                    );
                    showToast('Created streaming task in Habitica!', 'success');
                }
                
                APP_STATE.habitica.lastSync = Date.now();
                await saveToStore('settings', { key: 'habitica', value: APP_STATE.habitica });
                
                showToast('Habitica sync complete!', 'success');
                
            } catch (error) {
                showToast('Sync failed: ' + error.message, 'error');
            }
        }
        
        async function completeHabiticaStreamingTask() {
            if (!APP_STATE.habitica.enabled || !document.getElementById('habitica-auto-complete')?.checked) {
                return;
            }
            
            try {
                const tasks = await habiticaAPI.getUserTasks('dailys');
                const streamingTask = tasks.data.find(t => t.text.includes('Stream Content'));
                
                if (streamingTask && !streamingTask.completed) {
                    const result = await habiticaAPI.scoreTask(streamingTask.id, 'up');
                    
                    if (result.data) {
                        const xpGained = Math.floor(result.data.delta || 0);
                        const gpGained = Math.floor(result.data.gp || 0);
                        
                        showToast(`ğŸ‰ Habitica: +${xpGained} XP, +${gpGained} Gold!`, 'success');
                    }
                }
            } catch (error) {
                console.error('Failed to complete Habitica task:', error);
            }
        }
        
        // Toggle Habitica config visibility
        document.addEventListener('DOMContentLoaded', () => {
            const habiticaCheckbox = document.getElementById('habitica-enabled');
            if (habiticaCheckbox) {
                habiticaCheckbox.addEventListener('change', (e) => {
                    document.getElementById('habitica-config').style.display = e.target.checked ? 'block' : 'none';
                });
            }
        });
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           NETWORK MONITORING & ADAPTIVE BITRATE
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        
        class NetworkMonitor {
            constructor() {
                this.monitoringInterval = null;
                this.stats = {
                    bandwidth: 0,
                    latency: 0,
                    packetLoss: 0,
                    timestamp: Date.now()
                };
            }
            
            async start() {
                this.monitoringInterval = setInterval(async () => {
                    await this.updateStats();
                    this.updateUI();
                    
                    if (document.getElementById('enable-adaptive-bitrate').checked) {
                        this.adjustBitrate();
                    }
                }, 5000);
            }
            
            stop() {
                if (this.monitoringInterval) {
                    clearInterval(this.monitoringInterval);
                    this.monitoringInterval = null;
                }
            }
            
            async updateStats() {
                // Estimate bandwidth using Network Information API if available
                if ('connection' in navigator) {
                    const connection = navigator.connection;
                    if (connection.downlink) {
                        this.stats.bandwidth = connection.downlink;
                    }
                }
                
                // Measure latency with ping to streaming server
                if (APP_STATE.streaming && streamingEngine.connections.length > 0) {
                    const conn = streamingEngine.connections[0];
                    
                    if (conn.type === 'webrtc-whip' && conn.connection instanceof RTCPeerConnection) {
                        // Get WebRTC stats
                        const stats = await conn.connection.getStats();
                        
                        stats.forEach(report => {
                            if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                                this.stats.latency = report.currentRoundTripTime ? report.currentRoundTripTime * 1000 : 0;
                            }
                            
                            if (report.type === 'inbound-rtp') {
                                const packetsLost = report.packetsLost || 0;
                                const packetsReceived = report.packetsReceived || 1;
                                this.stats.packetLoss = (packetsLost / (packetsLost + packetsReceived)) * 100;
                            }
                        });
                    }
                }
            }
            
            updateUI() {
                document.getElementById('bandwidth-display').textContent = 
                    this.stats.bandwidth > 0 ? `${this.stats.bandwidth.toFixed(1)} Mbps` : '-- Mbps';
                
                document.getElementById('latency-display').textContent = 
                    this.stats.latency > 0 ? `${this.stats.latency.toFixed(0)} ms` : '-- ms';
                
                document.getElementById('packet-loss-display').textContent = 
                    this.stats.packetLoss > 0 ? `${this.stats.packetLoss.toFixed(2)} %` : '0 %';
                
                // Update stream health indicator
                const healthElement = document.getElementById('stream-health');
                let health = 'Excellent';
                let color = 'var(--success)';
                
                if (this.stats.packetLoss > 5 || this.stats.latency > 200) {
                    health = 'Poor';
                    color = 'var(--danger)';
                } else if (this.stats.packetLoss > 2 || this.stats.latency > 100) {
                    health = 'Fair';
                    color = 'var(--warning)';
                } else if (this.stats.packetLoss > 0.5 || this.stats.latency > 50) {
                    health = 'Good';
                    color = 'var(--primary)';
                }
                
                healthElement.textContent = health;
                healthElement.style.color = color;
            }
            
            adjustBitrate() {
                const currentBitrate = parseInt(document.getElementById('video-bitrate').value);
                let newBitrate = currentBitrate;
                
                // Adjust based on network conditions
                if (this.stats.bandwidth > 0) {
                    const targetBitrate = Math.floor(this.stats.bandwidth * 1000 * 0.7); // Use 70% of available bandwidth
                    
                    if (this.stats.packetLoss > 3) {
                        // Reduce bitrate if packet loss is high
                        newBitrate = Math.max(500, currentBitrate * 0.8);
                    } else if (this.stats.bandwidth > currentBitrate / 1000 * 1.5) {
                        // Increase bitrate if bandwidth allows
                        newBitrate = Math.min(targetBitrate, currentBitrate * 1.1);
                    }
                }
                
                if (Math.abs(newBitrate - currentBitrate) > 100) {
                    document.getElementById('video-bitrate').value = Math.round(newBitrate);
                    APP_STATE.streamSettings.videoBitrate = Math.round(newBitrate);
                    console.log(`Adaptive bitrate adjusted to ${newBitrate} kbps`);
                }
            }
        }
        
        const networkMonitor = new NetworkMonitor();
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           MULTI-SOURCE BROADCASTING SYSTEM
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Allow viewers to independently select which source to watch
           Method: Broadcast multiple sources simultaneously via separate tracks
           No OBS modification required - uses WebRTC MediaStream tracks
        */
        
        class MultiSourceBroadcaster {
            constructor() {
                this.sources = new Map(); // sourceId -> MediaStream
                this.activeBroadcasts = new Map(); // sourceId -> StreamingEngine
                this.sourceConfigs = new Map(); // sourceId -> config
            }
            
            async addSource(config) {
                const sourceId = `source_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                
                try {
                    let stream;
                    
                    switch (config.type) {
                        case 'screen':
                            stream = await navigator.mediaDevices.getDisplayMedia({
                                video: {
                                    width: { ideal: config.resolution?.width || 1920 },
                                    height: { ideal: config.resolution?.height || 1080 },
                                    frameRate: { ideal: config.framerate || 30 }
                                },
                                audio: config.captureAudio || false
                            });
                            break;
                            
                        case 'webcam':
                            stream = await navigator.mediaDevices.getUserMedia({
                                video: {
                                    width: { ideal: config.resolution?.width || 1280 },
                                    height: { ideal: config.resolution?.height || 720 },
                                    frameRate: { ideal: config.framerate || 30 },
                                    facingMode: config.facingMode || 'user'
                                },
                                audio: config.captureAudio || false
                            });
                            break;
                            
                        case 'window':
                            // Browser window capture (limited support)
                            stream = await navigator.mediaDevices.getDisplayMedia({
                                video: {
                                    displaySurface: 'window',
                                    width: { ideal: config.resolution?.width || 1920 },
                                    height: { ideal: config.resolution?.height || 1080 }
                                },
                                audio: config.captureAudio || false
                            });
                            break;
                            
                        case 'microphone':
                            stream = await navigator.mediaDevices.getUserMedia({
                                audio: {
                                    echoCancellation: true,
                                    noiseSuppression: true,
                                    autoGainControl: true,
                                    sampleRate: 48000
                                },
                                video: false
                            });
                            break;
                            
                        default:
                            throw new Error('Unknown source type');
                    }
                    
                    this.sources.set(sourceId, stream);
                    this.sourceConfigs.set(sourceId, {
                        ...config,
                        id: sourceId,
                        label: config.label || `${config.type} ${sourceId.substr(-6)}`,
                        addedAt: Date.now()
                    });
                    
                    // Add stop handler
                    stream.getTracks().forEach(track => {
                        track.onended = () => {
                            this.removeSource(sourceId);
                        };
                    });
                    
                    return {
                        sourceId: sourceId,
                        stream: stream,
                        config: this.sourceConfigs.get(sourceId)
                    };
                    
                } catch (error) {
                    console.error('Failed to add source:', error);
                    throw error;
                }
            }
            
            removeSource(sourceId) {
                const stream = this.sources.get(sourceId);
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    this.sources.delete(sourceId);
                }
                
                // Stop broadcasting if active
                if (this.activeBroadcasts.has(sourceId)) {
                    this.stopBroadcast(sourceId);
                }
                
                this.sourceConfigs.delete(sourceId);
                
                // Update UI
                renderSourceManager();
            }
            
            async startBroadcast(sourceId, destination) {
                const stream = this.sources.get(sourceId);
                const config = this.sourceConfigs.get(sourceId);
                
                if (!stream || !config) {
                    throw new Error('Source not found');
                }
                
                // Create dedicated streaming engine for this source
                const engine = new StreamingEngine();
                
                // Each source broadcasts to its own channel/endpoint
                // Append source ID to stream key for differentiation
                const modifiedDestination = {
                    ...destination,
                    streamKey: `${destination.streamKey}_${config.label.replace(/\s+/g, '_')}`
                };
                
                await engine.connect(
                    destination.protocol,
                    modifiedDestination.url,
                    modifiedDestination.streamKey,
                    stream
                );
                
                this.activeBroadcasts.set(sourceId, engine);
                config.broadcasting = true;
                
                return engine;
            }
            
            stopBroadcast(sourceId) {
                const engine = this.activeBroadcasts.get(sourceId);
                if (engine) {
                    engine.disconnect();
                    this.activeBroadcasts.delete(sourceId);
                }
                
                const config = this.sourceConfigs.get(sourceId);
                if (config) {
                    config.broadcasting = false;
                }
            }
            
            stopAllBroadcasts() {
                this.activeBroadcasts.forEach((engine, sourceId) => {
                    this.stopBroadcast(sourceId);
                });
            }
            
            getSources() {
                return Array.from(this.sourceConfigs.values());
            }
            
            getSource(sourceId) {
                return {
                    stream: this.sources.get(sourceId),
                    config: this.sourceConfigs.get(sourceId)
                };
            }
        }
        
        const multiSourceBroadcaster = new MultiSourceBroadcaster();
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           VIEWER-SIDE SOURCE SELECTION
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Allow viewers to independently select which source to watch
           Method: Subscribe to specific source streams via modified stream keys
        */
        
        class ViewerSourceSelector {
            constructor() {
                this.availableSources = [];
                this.currentSource = null;
                this.videoElement = null;
            }
            
            async fetchAvailableSources(streamerId) {
                // In production, this would query the streaming server
                // For demo, we'll simulate available sources
                
                // Example: Query server endpoint
                // const response = await fetch(`/api/streams/${streamerId}/sources`);
                // this.availableSources = await response.json();
                
                // Simulated response:
                this.availableSources = [
                    {
                        id: 'main_screen',
                        label: 'ğŸ–¥ï¸ Main Screen',
                        type: 'screen',
                        resolution: '1920x1080',
                        framerate: 60,
                        isDefault: true
                    },
                    {
                        id: 'webcam',
                        label: 'ğŸ“¹ Face Cam',
                        type: 'webcam',
                        resolution: '1280x720',
                        framerate: 30,
                        isDefault: false
                    },
                    {
                        id: 'secondary_screen',
                        label: 'ğŸ–¥ï¸ Secondary Screen',
                        type: 'screen',
                        resolution: '1920x1080',
                        framerate: 30,
                        isDefault: false
                    },
                    {
                        id: 'overhead_cam',
                        label: 'ğŸ“¸ Overhead Camera',
                        type: 'webcam',
                        resolution: '1920x1080',
                        framerate: 30,
                        isDefault: false
                    }
                ];
                
                return this.availableSources;
            }
            
            async switchToSource(sourceId, videoElement) {
                const source = this.availableSources.find(s => s.id === sourceId);
                if (!source) {
                    throw new Error('Source not found');
                }
                
                this.videoElement = videoElement || this.videoElement;
                
                // Stop current source if playing
                if (this.currentSource) {
                    this.stopCurrentSource();
                }
                
                // In production, this would connect to the specific source stream
                // Modified stream key format: basekey_sourcename
                const streamUrl = this.buildSourceStreamUrl(source);
                
                // Connect to source-specific stream
                await this.connectToSource(streamUrl, source);
                
                this.currentSource = source;
                
                // Update UI
                this.updateSourceSelectionUI(sourceId);
                
                // Track analytics
                this.trackSourceSwitch(sourceId);
                
                return source;
            }
            
            buildSourceStreamUrl(source) {
                // Build URL for specific source stream
                // Format depends on streaming protocol
                
                // For HLS:
                // return `https://stream.example.com/live/${streamerId}/${source.id}/index.m3u8`;
                
                // For WebRTC-WHIP:
                // return `https://whip.example.com/endpoint/${streamerId}/${source.id}`;
                
                // For demo, return simulated URL
                return `https://demo-stream.sanctuary.app/source/${source.id}`;
            }
            
            async connectToSource(url, source) {
                // Implementation depends on streaming protocol
                
                // Example for HLS:
                if (window.Hls && window.Hls.isSupported()) {
                    const hls = new window.Hls();
                    hls.loadSource(url);
                    hls.attachMedia(this.videoElement);
                    this.hlsInstance = hls;
                }
                // Example for native HLS (Safari)
                else if (this.videoElement.canPlayType('application/vnd.apple.mpegurl')) {
                    this.videoElement.src = url;
                }
                // Example for WebRTC
                else {
                    // WebRTC connection logic here
                    console.log('Connecting to WebRTC source:', url);
                }
                
                // For demo purposes, show source info
                console.log(`Connected to source: ${source.label}`);
                showToast(`Now viewing: ${source.label}`, 'success');
            }
            
            stopCurrentSource() {
                if (this.hlsInstance) {
                    this.hlsInstance.destroy();
                    this.hlsInstance = null;
                }
                
                if (this.videoElement) {
                    this.videoElement.src = '';
                }
            }
            
            updateSourceSelectionUI(sourceId) {
                document.querySelectorAll('.source-selector-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.sourceId === sourceId) {
                        btn.classList.add('active');
                    }
                });
            }
            
            trackSourceSwitch(sourceId) {
                // Track which sources viewers prefer
                saveToStore('analytics', {
                    date: new Date().toISOString().split('T')[0],
                    type: 'source_switch',
                    sourceId: sourceId,
                    timestamp: Date.now()
                });
            }
        }
        
        const viewerSourceSelector = new ViewerSourceSelector();
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           SOURCE MANAGER UI
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        
        async function renderSourceManager() {
            const container = document.getElementById('source-manager-list');
            if (!container) return;
            
            const sources = multiSourceBroadcaster.getSources();
            
            if (sources.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: var(--text-dim);">
                        No sources added yet. Click "Add Source" to start broadcasting multiple streams.
                    </div>
                `;
                return;
            }
            
            container.innerHTML = '';
            
            sources.forEach(source => {
                const sourceCard = document.createElement('div');
                sourceCard.className = 'source-card';
                sourceCard.style.cssText = `
                    background: var(--surface);
                    border: 1px solid var(--border);
                    border-radius: 12px;
                    padding: 1.5rem;
                    margin-bottom: 1rem;
                `;
                
                const typeIcon = {
                    'screen': 'ğŸ–¥ï¸',
                    'webcam': 'ğŸ“¹',
                    'window': 'ğŸªŸ',
                    'microphone': 'ğŸ¤'
                }[source.type] || 'ğŸ“º';
                
                sourceCard.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="flex: 1;">
                            <h4 style="margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem;">
                                <span style="font-size: 1.5rem;">${typeIcon}</span>
                                ${source.label}
                                ${source.broadcasting ? '<span style="color: var(--danger); font-size: 0.9rem; margin-left: 0.5rem;">ğŸ”´ LIVE</span>' : ''}
                            </h4>
                            <div style="color: var(--text-dim); font-size: 0.9rem;">
                                ${source.type} â€¢ ${source.resolution?.width || 'auto'}x${source.resolution?.height || 'auto'} â€¢ ${source.framerate || 30}fps
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 0.5rem;">
                            ${source.broadcasting ? `
                                <button class="btn btn-danger" onclick="stopSourceBroadcast('${source.id}')" style="padding: 0.5rem 1rem;">
                                    â¹ï¸ Stop
                                </button>
                            ` : `
                                <button class="btn btn-success" onclick="startSourceBroadcast('${source.id}')" style="padding: 0.5rem 1rem;">
                                    ğŸš€ Start
                                </button>
                            `}
                            <button class="btn btn-secondary" onclick="previewSource('${source.id}')" style="padding: 0.5rem 1rem;">
                                ğŸ‘ï¸ Preview
                            </button>
                            <button class="btn btn-danger" onclick="removeSource('${source.id}')" style="padding: 0.5rem 1rem;">
                                ğŸ—‘ï¸ Remove
                            </button>
                        </div>
                    </div>
                `;
                
                container.appendChild(sourceCard);
            });
        }
        
        async function addNewSource() {
            const type = await showSourceTypeModal();
            if (!type) return;
            
            const config = {
                type: type,
                captureAudio: type === 'screen' || type === 'microphone',
                framerate: type === 'webcam' ? 30 : 60,
                label: prompt(`Enter a label for this ${type}:`) || `${type} source`
            };
            
            try {
                const result = await multiSourceBroadcaster.addSource(config);
                showToast(`Added source: ${result.config.label}`, 'success');
                renderSourceManager();
                
                // Auto-preview the new source
                previewSource(result.sourceId);
                
            } catch (error) {
                showToast(`Failed to add source: ${error.message}`, 'error');
            }
        }
        
        function showSourceTypeModal() {
            return new Promise((resolve) => {
                const modal = document.createElement('div');
                modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; align-items: center; justify-content: center;';
                
                modal.innerHTML = `
                    <div style="background: var(--surface); border-radius: 16px; padding: 2rem; max-width: 600px;">
                        <h2 style="margin-bottom: 1.5rem;">Select Source Type</h2>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                            <button class="btn btn-primary" onclick="selectSourceType('screen')" style="padding: 2rem; font-size: 1.1rem;">
                                ğŸ–¥ï¸<br>Screen Share
                            </button>
                            <button class="btn btn-primary" onclick="selectSourceType('webcam')" style="padding: 2rem; font-size: 1.1rem;">
                                ğŸ“¹<br>Webcam
                            </button>
                            <button class="btn btn-primary" onclick="selectSourceType('window')" style="padding: 2rem; font-size: 1.1rem;">
                                ğŸªŸ<br>Window
                            </button>
                            <button class="btn btn-primary" onclick="selectSourceType('microphone')" style="padding: 2rem; font-size: 1.1rem;">
                                ğŸ¤<br>Microphone
                            </button>
                        </div>
                        <button class="btn btn-secondary" onclick="cancelSourceType()" style="width: 100%; margin-top: 1rem;">
                            Cancel
                        </button>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                window.selectSourceType = (type) => {
                    document.body.removeChild(modal);
                    delete window.selectSourceType;
                    delete window.cancelSourceType;
                    resolve(type);
                };
                
                window.cancelSourceType = () => {
                    document.body.removeChild(modal);
                    delete window.selectSourceType;
                    delete window.cancelSourceType;
                    resolve(null);
                };
            });
        }
        
        async function startSourceBroadcast(sourceId) {
            const destination = {
                protocol: APP_STATE.currentProtocol || 'webrtc-whip',
                url: document.getElementById('rtmp-url').value,
                streamKey: document.getElementById('stream-key').value
            };
            
            if (!destination.url || !destination.streamKey) {
                showToast('Please configure stream destination first', 'warning');
                return;
            }
            
            try {
                await multiSourceBroadcaster.startBroadcast(sourceId, destination);
                showToast('Source broadcasting started!', 'success');
                renderSourceManager();
            } catch (error) {
                showToast(`Failed to start broadcast: ${error.message}`, 'error');
            }
        }
        
        async function stopSourceBroadcast(sourceId) {
            multiSourceBroadcaster.stopBroadcast(sourceId);
            showToast('Source broadcast stopped', 'success');
            renderSourceManager();
        }
        
        function removeSource(sourceId) {
            if (confirm('Remove this source? This will stop any active broadcasts.')) {
                multiSourceBroadcaster.removeSource(sourceId);
                showToast('Source removed', 'success');
            }
        }
        
        function previewSource(sourceId) {
            const { stream, config } = multiSourceBroadcaster.getSource(sourceId);
            if (!stream) return;
            
            const previewVideo = document.getElementById('preview-video');
            if (previewVideo) {
                previewVideo.srcObject = stream;
                showToast(`Previewing: ${config.label}`, 'success');
            }
        }
        
        // Viewer-side functions
        async function loadViewerSourceSelector(streamerId) {
            const sources = await viewerSourceSelector.fetchAvailableSources(streamerId);
            renderViewerSourceSelector(sources);
        }
        
        function renderViewerSourceSelector(sources) {
            const container = document.getElementById('viewer-source-selector');
            if (!container) return;
            
            container.innerHTML = `
                <div style="background: var(--surface); border-radius: 12px; padding: 1rem; margin-bottom: 1rem;">
                    <h4 style="margin-bottom: 1rem;">ğŸ“º Choose Your View</h4>
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        ${sources.map(source => `
                            <button 
                                class="btn source-selector-btn ${source.isDefault ? 'active' : ''}" 
                                data-source-id="${source.id}"
                                onclick="switchViewerSource('${source.id}')"
                                style="padding: 0.75rem 1rem;">
                                ${source.label}
                                ${source.isDefault ? ' (Default)' : ''}
                            </button>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        async function switchViewerSource(sourceId) {
            const videoElement = document.getElementById('viewer-video') || document.getElementById('preview-video');
            
            try {
                await viewerSourceSelector.switchToSource(sourceId, videoElement);
            } catch (error) {
                showToast(`Failed to switch source: ${error.message}`, 'error');
            }
        }
        
        async function startAllSourceBroadcasts() {
            const destination = {
                protocol: APP_STATE.currentProtocol || 'webrtc-whip',
                url: document.getElementById('rtmp-url').value,
                streamKey: document.getElementById('stream-key').value
            };
            
            if (!destination.url || !destination.streamKey) {
                showToast('Please configure stream destination first', 'warning');
                return;
            }
            
            const sources = multiSourceBroadcaster.getSources();
            let started = 0;
            let failed = 0;
            
            for (const source of sources) {
                if (!source.broadcasting) {
                    try {
                        await multiSourceBroadcaster.startBroadcast(source.id, destination);
                        started++;
                    } catch (error) {
                        console.error(`Failed to start ${source.label}:`, error);
                        failed++;
                    }
                }
            }
            
            showToast(`Started ${started} source(s). ${failed > 0 ? `Failed: ${failed}` : ''}`, 'success');
            renderSourceManager();
        }
        
        function stopAllSourceBroadcasts() {
            multiSourceBroadcaster.stopAllBroadcasts();
            showToast('All source broadcasts stopped', 'success');
            renderSourceManager();
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           STREAM CATEGORIES & CONTAINERIZATION SYSTEM
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Purpose: Organize streams into isolated categories with preview snapshots
           Usage: Each category is a mini-homepage with cached thumbnails
           Expected: Single-page navigation, no profile pages needed
        */
        
        async function createCategory() {
            const name = prompt('Category name (e.g., Gaming, Tutorials, Music):');
            if (!name) return;
            
            const description = prompt('Description (optional):') || '';
            
            const category = {
                name: name,
                description: description,
                created: Date.now(),
                streamCount: 0,
                lastStream: null,
                thumbnailColor: `hsl(${Math.random() * 360}, 70%, 50%)`
            };
            
            const id = await saveToStore('categories', category);
            category.id = id;
            
            APP_STATE.streamCategories.push(category);
            
            showToast(`Created category: ${name}`, 'success');
            renderCategories();
        }
        
        async function loadCategories() {
            APP_STATE.streamCategories = await getAllFromStore('categories');
            renderCategories();
        }
        
        function renderCategories() {
            const grid = document.getElementById('categories-grid');
            
            if (APP_STATE.streamCategories.length === 0) {
                grid.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 3rem; color: var(--text-dim);">
                        <div style="font-size: 4rem; margin-bottom: 1rem;">ğŸ“‚</div>
                        <div style="font-size: 1.2rem; margin-bottom: 1rem;">No categories yet</div>
                        <div>Create your first category to organize your streams</div>
                    </div>
                `;
                return;
            }
            
            grid.innerHTML = '';
            
            APP_STATE.streamCategories.forEach(category => {
                const card = document.createElement('div');
                card.style.cssText = `
                    background: linear-gradient(135deg, ${category.thumbnailColor}22, var(--surface));
                    border: 2px solid ${category.thumbnailColor};
                    border-radius: 16px;
                    padding: 1.5rem;
                    cursor: pointer;
                    transition: transform 0.3s, box-shadow 0.3s;
                    position: relative;
                    overflow: hidden;
                `;
                
                card.innerHTML = `
                    <div style="position: relative; z-index: 1;">
                        <div style="font-size: 3rem; margin-bottom: 1rem; text-align: center;">
                            ${getCategoryIcon(category.name)}
                        </div>
                        <h3 style="margin-bottom: 0.5rem; text-align: center; color: var(--text);">
                            ${category.name}
                        </h3>
                        <div style="text-align: center; color: var(--text-dim); font-size: 0.9rem; margin-bottom: 1rem;">
                            ${category.streamCount || 0} streams
                        </div>
                        ${category.description ? `
                            <div style="text-align: center; color: var(--text-dim); font-size: 0.85rem; margin-bottom: 1rem;">
                                ${category.description}
                            </div>
                        ` : ''}
                        <button class="btn btn-primary" style="width: 100%; padding: 0.75rem;" onclick="openCategory(${category.id})">
                            ğŸš€ Open Streaming Environment
                        </button>
                        <button class="btn btn-secondary" style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; font-size: 0.9rem;" onclick="deleteCategory(${category.id}, event)">
                            ğŸ—‘ï¸ Delete
                        </button>
                    </div>
                `;
                
                card.addEventListener('mouseenter', () => {
                    card.style.transform = 'translateY(-8px)';
                    card.style.boxShadow = `0 12px 40px ${category.thumbnailColor}44`;
                });
                
                card.addEventListener('mouseleave', () => {
                    card.style.transform = 'translateY(0)';
                    card.style.boxShadow = 'none';
                });
                
                grid.appendChild(card);
            });
        }
        
        function getCategoryIcon(name) {
            const icons = {
                'gaming': 'ğŸ®',
                'tutorial': 'ğŸ“š',
                'music': 'ğŸµ',
                'art': 'ğŸ¨',
                'coding': 'ğŸ’»',
                'talk': 'ğŸ’¬',
                'podcast': 'ğŸ™ï¸',
                'fitness': 'ğŸ’ª',
                'cooking': 'ğŸ‘¨â€ğŸ³',
                'education': 'ğŸ“–'
            };
            
            const lower = name.toLowerCase();
            for (const [key, icon] of Object.entries(icons)) {
                if (lower.includes(key)) return icon;
            }
            
            return 'ğŸ“º';
        }
        
        async function openCategory(categoryId) {
            const category = APP_STATE.streamCategories.find(c => c.id === categoryId);
            if (!category) return;
            
            APP_STATE.activeStreamCategory = categoryId;
            
            // Show containerized view
            const container = document.getElementById('active-stream-container');
            const content = document.getElementById('container-content');
            
            document.getElementById('container-category-name').textContent = `${getCategoryIcon(category.name)} ${category.name}`;
            
            // Clone the main streaming interface into container
            content.innerHTML = `
                <div style="margin-bottom: 2rem; padding: 1rem; background: var(--surface); border-radius: 12px; border-left: 4px solid ${category.thumbnailColor};">
                    <div style="font-size: 0.9rem; color: var(--text-dim);">
                        <strong>Category:</strong> ${category.name} â€¢ 
                        <strong>Streams:</strong> ${category.streamCount || 0} â€¢ 
                        <strong>Status:</strong> ${APP_STATE.streaming ? 'ğŸ”´ Live' : 'âš« Offline'}
                    </div>
                </div>
                
                <!-- Stream Preview (from main page) -->
                <div class="section">
                    <div class="section-header">
                        <div class="section-title">
                            <span class="section-icon">ğŸ“º</span>
                            Stream Preview - ${category.name}
                        </div>
                        <span class="section-toggle">â–¼</span>
                    </div>
                    <div class="section-content">
                        <div class="preview-container">
                            <video id="container-preview-video" autoplay muted playsinline></video>
                            <div class="preview-overlay">
                                <div class="preview-badge">
                                    <span id="container-preview-status">âš« Not Streaming</span>
                                </div>
                                <div class="preview-badge">
                                    <span id="container-preview-resolution">1920x1080</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label>Audio Level</label>
                            <div class="audio-meter">
                                <div class="audio-meter-fill" id="container-audio-meter"></div>
                            </div>
                        </div>
                        
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="startCapture()">
                                ğŸ¬ Start Capture
                            </button>
                            <button class="btn btn-danger" onclick="stopCapture()" disabled>
                                â¹ï¸ Stop Capture
                            </button>
                            <button class="btn btn-success" onclick="startCategoryStream(${categoryId})" disabled id="container-start-stream">
                                ğŸš€ Start Streaming
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Stream History for this category -->
                <div class="section" style="margin-top: 2rem;">
                    <div class="section-header">
                        <div class="section-title">
                            <span class="section-icon">ğŸ“Š</span>
                            Stream History - ${category.name}
                        </div>
                        <span class="section-toggle">â–¼</span>
                    </div>
                    <div class="section-content">
                        <div id="container-history-list">
                            <!-- Populated by loadCategoryHistory -->
                        </div>
                    </div>
                </div>
            `;
            
            container.style.display = 'block';
            
            // Sync preview video if already capturing
            if (APP_STATE.capturing && APP_STATE.mediaStream) {
                const containerVideo = document.getElementById('container-preview-video');
                containerVideo.srcObject = APP_STATE.mediaStream;
                document.getElementById('container-start-stream').disabled = false;
            }
            
            // Load category-specific history
            await loadCategoryHistory(categoryId);
            
            // Initialize collapsible sections in container
            document.querySelectorAll('#container-content .section-header').forEach(header => {
                header.addEventListener('click', () => {
                    header.parentElement.classList.toggle('collapsed');
                });
            });
        }
        
        function closeStreamContainer() {
            document.getElementById('active-stream-container').style.display = 'none';
            APP_STATE.activeStreamCategory = null;
        }
        
        async function startCategoryStream(categoryId) {
            if (!APP_STATE.capturing) {
                showToast('Please start screen capture first!', 'warning');
                return;
            }
            
            // Set category context
            APP_STATE.activeStreamCategory = categoryId;
            
            // Start normal stream
            await startStream();
            
            // Capture snapshot for thumbnail
            await captureStreamSnapshot(categoryId);
            
            // Update category stream count
            const category = APP_STATE.streamCategories.find(c => c.id === categoryId);
            if (category) {
                category.streamCount = (category.streamCount || 0) + 1;
                category.lastStream = Date.now();
                await saveToStore('categories', category);
            }
        }
        
        async function captureStreamSnapshot(categoryId) {
            const video = document.getElementById('preview-video') || document.getElementById('container-preview-video');
            if (!video || !video.srcObject) return;
            
            // Create canvas to capture frame
            const canvas = document.createElement('canvas');
            canvas.width = 320; // Thumbnail width
            canvas.height = 180; // Thumbnail height (16:9)
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // Convert to base64
            const thumbnail = canvas.toDataURL('image/jpeg', 0.7);
            
            // Save snapshot
            const snapshot = {
                streamId: Date.now(),
                categoryId: categoryId,
                thumbnail: thumbnail,
                timestamp: Date.now()
            };
            
            await saveToStore('snapshots', snapshot);
        }
        
        async function loadCategoryHistory(categoryId) {
            const allStreams = await getAllFromStore('streams');
            const categoryStreams = allStreams.filter(s => s.category === categoryId);
            
            const list = document.getElementById('container-history-list');
            
            if (categoryStreams.length === 0) {
                list.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-dim);">No streams in this category yet</div>';
                return;
            }
            
            list.innerHTML = '';
            
            for (const stream of categoryStreams) {
                const item = document.createElement('div');
                item.className = 'history-item';
                
                const date = new Date(stream.timestamp);
                const duration = formatDuration(stream.duration);
                
                item.innerHTML = `
                    <div class="history-info">
                        <div class="history-title">
                            ${PLATFORM_PRESETS[stream.platform]?.name || 'Custom'} Stream
                        </div>
                        <div class="history-meta">
                            ${date.toLocaleString()} â€¢ ${duration} â€¢ ${stream.resolution}
                        </div>
                    </div>
                `;
                
                list.appendChild(item);
            }
        }
        
        async function deleteCategory(categoryId, event) {
            event.stopPropagation();
            
            const category = APP_STATE.streamCategories.find(c => c.id === categoryId);
            if (!confirm(`Delete category "${category.name}"? This will not delete your streams.`)) {
                return;
            }
            
            // Delete from IndexedDB
            const transaction = db.transaction(['categories'], 'readwrite');
            const store = transaction.objectStore('categories');
            await store.delete(categoryId);
            
            // Remove from state
            APP_STATE.streamCategories = APP_STATE.streamCategories.filter(c => c.id !== categoryId);
            
            showToast('Category deleted', 'success');
            renderCategories();
        }
        
        function viewAllStreams() {
            // Show all streams across all categories
            showToast('Feature: View all streams across categories', 'success');
            // TODO: Implement unified stream view
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           INITIALIZATION
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        */
        
        async function init() {
            try {
                // Initialize IndexedDB
                await initDB();
                
                // Load saved role
                const savedRole = await loadFromStore('settings', 'role');
                if (savedRole) {
                    APP_STATE.role = savedRole.value;
                    localStorage.setItem('role', savedRole.value);
                }
                
                // Load saved currencies
                const savedCurrencies = await loadFromStore('settings', 'currencies');
                if (savedCurrencies) {
                    APP_STATE.currencies = savedCurrencies.value;
                }
                
                // Load saved level
                const savedLevel = await loadFromStore('settings', 'level');
                if (savedLevel) {
                    APP_STATE.level = savedLevel.value;
                    document.getElementById('level-count').textContent = APP_STATE.level;
                }
                
                // Load Habitica settings
                const savedHabitica = await loadFromStore('settings', 'habitica');
                if (savedHabitica && savedHabitica.value) {
                    APP_STATE.habitica = savedHabitica.value;
                    
                    if (APP_STATE.habitica.enabled) {
                        document.getElementById('habitica-enabled').checked = true;
                        document.getElementById('habitica-config').style.display = 'block';
                        document.getElementById('habitica-user-id').value = APP_STATE.habitica.userId || '';
                        document.getElementById('habitica-api-token').value = APP_STATE.habitica.apiToken || '';
                        
                        habiticaAPI.setCredentials(APP_STATE.habitica.userId, APP_STATE.habitica.apiToken);
                    }
                }
                
                // Load saved RTMP settings
                const savedRTMP = await loadFromStore('settings', 'rtmp');
                if (savedRTMP) {
                    APP_STATE.rtmpSettings = savedRTMP.value;
                    document.getElementById('rtmp-url').value = savedRTMP.value.url || '';
                    document.getElementById('stream-key').value = savedRTMP.value.key || '';
                }
                
                // Load multistream destinations
                const savedMultistream = await loadFromStore('settings', 'multistream');
                if (savedMultistream && savedMultistream.value) {
                    APP_STATE.multistreamDestinations = savedMultistream.value;
                    if (APP_STATE.multistreamDestinations.length > 0) {
                        document.getElementById('enable-multistream').checked = true;
                        document.getElementById('multistream-container').style.display = 'block';
                        renderMultistreamDestinations();
                    }
                }
                
                // Load achievements
                const savedAchievements = await getAllFromStore('achievements');
                APP_STATE.achievements = savedAchievements.map(a => a.id);
                renderAchievements();
                
                // Load history
                await loadHistory();
                
                // Load categories
                await loadCategories();
                
                // Load mnemonic system
                await loadMnemonicDecks();
                await updateMnemonicStats();
                
                // Initialize UI components
                initCollapsibleSections();
                initRoleSystem();
                
                // Initialize constellation
                resizeCanvas();
                initParticles();
                animateConstellation();
                
                // Mouse tracking for parallax
                window.addEventListener('mousemove', (e) => {
                    mouse.x = e.clientX;
                    mouse.y = e.clientY;
                });
                
                window.addEventListener('resize', () => {
                    resizeCanvas();
                    initParticles();
                });
                
                console.log('ğŸ‰ Stream Sanctuary initialized successfully!');
                
            } catch (error) {
                console.error('Initialization error:', error);
                showToast('Error initializing application', 'error');
            }
        }
        
        // Initialize on DOM ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
